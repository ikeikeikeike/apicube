// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// DTBCustomer is an object representing the database table.
type DTBCustomer struct {
	ID                uint              `boil:"id" json:"id" toml:"id" yaml:"id"`
	CustomerStatusID  null.Uint16       `boil:"customer_status_id" json:"customer_status_id,omitempty" toml:"customer_status_id" yaml:"customer_status_id,omitempty"`
	SexID             null.Uint16       `boil:"sex_id" json:"sex_id,omitempty" toml:"sex_id" yaml:"sex_id,omitempty"`
	JobID             null.Uint16       `boil:"job_id" json:"job_id,omitempty" toml:"job_id" yaml:"job_id,omitempty"`
	CountryID         null.Uint16       `boil:"country_id" json:"country_id,omitempty" toml:"country_id" yaml:"country_id,omitempty"`
	PrefID            null.Uint16       `boil:"pref_id" json:"pref_id,omitempty" toml:"pref_id" yaml:"pref_id,omitempty"`
	Name01            string            `boil:"name01" json:"name01" toml:"name01" yaml:"name01"`
	Name02            string            `boil:"name02" json:"name02" toml:"name02" yaml:"name02"`
	Kana01            null.String       `boil:"kana01" json:"kana01,omitempty" toml:"kana01" yaml:"kana01,omitempty"`
	Kana02            null.String       `boil:"kana02" json:"kana02,omitempty" toml:"kana02" yaml:"kana02,omitempty"`
	CompanyName       null.String       `boil:"company_name" json:"company_name,omitempty" toml:"company_name" yaml:"company_name,omitempty"`
	PostalCode        null.String       `boil:"postal_code" json:"postal_code,omitempty" toml:"postal_code" yaml:"postal_code,omitempty"`
	Addr01            null.String       `boil:"addr01" json:"addr01,omitempty" toml:"addr01" yaml:"addr01,omitempty"`
	Addr02            null.String       `boil:"addr02" json:"addr02,omitempty" toml:"addr02" yaml:"addr02,omitempty"`
	Email             string            `boil:"email" json:"email" toml:"email" yaml:"email"`
	PhoneNumber       null.String       `boil:"phone_number" json:"phone_number,omitempty" toml:"phone_number" yaml:"phone_number,omitempty"`
	Birth             null.Time         `boil:"birth" json:"birth,omitempty" toml:"birth" yaml:"birth,omitempty"`
	Password          string            `boil:"password" json:"password" toml:"password" yaml:"password"`
	Salt              null.String       `boil:"salt" json:"salt,omitempty" toml:"salt" yaml:"salt,omitempty"`
	SecretKey         string            `boil:"secret_key" json:"secret_key" toml:"secret_key" yaml:"secret_key"`
	FirstBuyDate      null.Time         `boil:"first_buy_date" json:"first_buy_date,omitempty" toml:"first_buy_date" yaml:"first_buy_date,omitempty"`
	LastBuyDate       null.Time         `boil:"last_buy_date" json:"last_buy_date,omitempty" toml:"last_buy_date" yaml:"last_buy_date,omitempty"`
	BuyTimes          types.NullDecimal `boil:"buy_times" json:"buy_times,omitempty" toml:"buy_times" yaml:"buy_times,omitempty"`
	BuyTotal          types.NullDecimal `boil:"buy_total" json:"buy_total,omitempty" toml:"buy_total" yaml:"buy_total,omitempty"`
	Note              null.String       `boil:"note" json:"note,omitempty" toml:"note" yaml:"note,omitempty"`
	ResetKey          null.String       `boil:"reset_key" json:"reset_key,omitempty" toml:"reset_key" yaml:"reset_key,omitempty"`
	ResetExpire       null.Time         `boil:"reset_expire" json:"reset_expire,omitempty" toml:"reset_expire" yaml:"reset_expire,omitempty"`
	Point             types.Decimal     `boil:"point" json:"point" toml:"point" yaml:"point"`
	CreateDate        time.Time         `boil:"create_date" json:"create_date" toml:"create_date" yaml:"create_date"`
	UpdateDate        time.Time         `boil:"update_date" json:"update_date" toml:"update_date" yaml:"update_date"`
	DiscriminatorType string            `boil:"discriminator_type" json:"discriminator_type" toml:"discriminator_type" yaml:"discriminator_type"`

	R *dtbCustomerR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dtbCustomerL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DTBCustomerColumns = struct {
	ID                string
	CustomerStatusID  string
	SexID             string
	JobID             string
	CountryID         string
	PrefID            string
	Name01            string
	Name02            string
	Kana01            string
	Kana02            string
	CompanyName       string
	PostalCode        string
	Addr01            string
	Addr02            string
	Email             string
	PhoneNumber       string
	Birth             string
	Password          string
	Salt              string
	SecretKey         string
	FirstBuyDate      string
	LastBuyDate       string
	BuyTimes          string
	BuyTotal          string
	Note              string
	ResetKey          string
	ResetExpire       string
	Point             string
	CreateDate        string
	UpdateDate        string
	DiscriminatorType string
}{
	ID:                "id",
	CustomerStatusID:  "customer_status_id",
	SexID:             "sex_id",
	JobID:             "job_id",
	CountryID:         "country_id",
	PrefID:            "pref_id",
	Name01:            "name01",
	Name02:            "name02",
	Kana01:            "kana01",
	Kana02:            "kana02",
	CompanyName:       "company_name",
	PostalCode:        "postal_code",
	Addr01:            "addr01",
	Addr02:            "addr02",
	Email:             "email",
	PhoneNumber:       "phone_number",
	Birth:             "birth",
	Password:          "password",
	Salt:              "salt",
	SecretKey:         "secret_key",
	FirstBuyDate:      "first_buy_date",
	LastBuyDate:       "last_buy_date",
	BuyTimes:          "buy_times",
	BuyTotal:          "buy_total",
	Note:              "note",
	ResetKey:          "reset_key",
	ResetExpire:       "reset_expire",
	Point:             "point",
	CreateDate:        "create_date",
	UpdateDate:        "update_date",
	DiscriminatorType: "discriminator_type",
}

// Generated where

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Time) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var DTBCustomerWhere = struct {
	ID                whereHelperuint
	CustomerStatusID  whereHelpernull_Uint16
	SexID             whereHelpernull_Uint16
	JobID             whereHelpernull_Uint16
	CountryID         whereHelpernull_Uint16
	PrefID            whereHelpernull_Uint16
	Name01            whereHelperstring
	Name02            whereHelperstring
	Kana01            whereHelpernull_String
	Kana02            whereHelpernull_String
	CompanyName       whereHelpernull_String
	PostalCode        whereHelpernull_String
	Addr01            whereHelpernull_String
	Addr02            whereHelpernull_String
	Email             whereHelperstring
	PhoneNumber       whereHelpernull_String
	Birth             whereHelpernull_Time
	Password          whereHelperstring
	Salt              whereHelpernull_String
	SecretKey         whereHelperstring
	FirstBuyDate      whereHelpernull_Time
	LastBuyDate       whereHelpernull_Time
	BuyTimes          whereHelpertypes_NullDecimal
	BuyTotal          whereHelpertypes_NullDecimal
	Note              whereHelpernull_String
	ResetKey          whereHelpernull_String
	ResetExpire       whereHelpernull_Time
	Point             whereHelpertypes_Decimal
	CreateDate        whereHelpertime_Time
	UpdateDate        whereHelpertime_Time
	DiscriminatorType whereHelperstring
}{
	ID:                whereHelperuint{field: `id`},
	CustomerStatusID:  whereHelpernull_Uint16{field: `customer_status_id`},
	SexID:             whereHelpernull_Uint16{field: `sex_id`},
	JobID:             whereHelpernull_Uint16{field: `job_id`},
	CountryID:         whereHelpernull_Uint16{field: `country_id`},
	PrefID:            whereHelpernull_Uint16{field: `pref_id`},
	Name01:            whereHelperstring{field: `name01`},
	Name02:            whereHelperstring{field: `name02`},
	Kana01:            whereHelpernull_String{field: `kana01`},
	Kana02:            whereHelpernull_String{field: `kana02`},
	CompanyName:       whereHelpernull_String{field: `company_name`},
	PostalCode:        whereHelpernull_String{field: `postal_code`},
	Addr01:            whereHelpernull_String{field: `addr01`},
	Addr02:            whereHelpernull_String{field: `addr02`},
	Email:             whereHelperstring{field: `email`},
	PhoneNumber:       whereHelpernull_String{field: `phone_number`},
	Birth:             whereHelpernull_Time{field: `birth`},
	Password:          whereHelperstring{field: `password`},
	Salt:              whereHelpernull_String{field: `salt`},
	SecretKey:         whereHelperstring{field: `secret_key`},
	FirstBuyDate:      whereHelpernull_Time{field: `first_buy_date`},
	LastBuyDate:       whereHelpernull_Time{field: `last_buy_date`},
	BuyTimes:          whereHelpertypes_NullDecimal{field: `buy_times`},
	BuyTotal:          whereHelpertypes_NullDecimal{field: `buy_total`},
	Note:              whereHelpernull_String{field: `note`},
	ResetKey:          whereHelpernull_String{field: `reset_key`},
	ResetExpire:       whereHelpernull_Time{field: `reset_expire`},
	Point:             whereHelpertypes_Decimal{field: `point`},
	CreateDate:        whereHelpertime_Time{field: `create_date`},
	UpdateDate:        whereHelpertime_Time{field: `update_date`},
	DiscriminatorType: whereHelperstring{field: `discriminator_type`},
}

// DTBCustomerRels is where relationship names are stored.
var DTBCustomerRels = struct {
	Sex                                 string
	Job                                 string
	CustomerStatus                      string
	Pref                                string
	Country                             string
	CustomerDTBCarts                    string
	CustomerDTBCustomerAddresses        string
	CustomerDTBCustomerFavoriteProducts string
	CustomerDTBOrders                   string
}{
	Sex:                                 "Sex",
	Job:                                 "Job",
	CustomerStatus:                      "CustomerStatus",
	Pref:                                "Pref",
	Country:                             "Country",
	CustomerDTBCarts:                    "CustomerDTBCarts",
	CustomerDTBCustomerAddresses:        "CustomerDTBCustomerAddresses",
	CustomerDTBCustomerFavoriteProducts: "CustomerDTBCustomerFavoriteProducts",
	CustomerDTBOrders:                   "CustomerDTBOrders",
}

// dtbCustomerR is where relationships are stored.
type dtbCustomerR struct {
	Sex                                 *MTBSex
	Job                                 *MTBJob
	CustomerStatus                      *MTBCustomerStatus
	Pref                                *MTBPref
	Country                             *MTBCountry
	CustomerDTBCarts                    DTBCartSlice
	CustomerDTBCustomerAddresses        DTBCustomerAddressSlice
	CustomerDTBCustomerFavoriteProducts DTBCustomerFavoriteProductSlice
	CustomerDTBOrders                   DTBOrderSlice
}

// NewStruct creates a new relationship struct
func (*dtbCustomerR) NewStruct() *dtbCustomerR {
	return &dtbCustomerR{}
}

// dtbCustomerL is where Load methods for each relationship are stored.
type dtbCustomerL struct{}

var (
	dtbCustomerColumns               = []string{"id", "customer_status_id", "sex_id", "job_id", "country_id", "pref_id", "name01", "name02", "kana01", "kana02", "company_name", "postal_code", "addr01", "addr02", "email", "phone_number", "birth", "password", "salt", "secret_key", "first_buy_date", "last_buy_date", "buy_times", "buy_total", "note", "reset_key", "reset_expire", "point", "create_date", "update_date", "discriminator_type"}
	dtbCustomerColumnsWithoutDefault = []string{"customer_status_id", "sex_id", "job_id", "country_id", "pref_id", "name01", "name02", "kana01", "kana02", "company_name", "postal_code", "addr01", "addr02", "email", "phone_number", "birth", "password", "salt", "secret_key", "first_buy_date", "last_buy_date", "note", "reset_key", "reset_expire", "create_date", "update_date", "discriminator_type"}
	dtbCustomerColumnsWithDefault    = []string{"id", "buy_times", "buy_total", "point"}
	dtbCustomerPrimaryKeyColumns     = []string{"id"}
)

type (
	// DTBCustomerSlice is an alias for a slice of pointers to DTBCustomer.
	// This should generally be used opposed to []DTBCustomer.
	DTBCustomerSlice []*DTBCustomer
	// DTBCustomerHook is the signature for custom DTBCustomer hook methods
	DTBCustomerHook func(context.Context, boil.ContextExecutor, *DTBCustomer) error

	dtbCustomerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dtbCustomerType                 = reflect.TypeOf(&DTBCustomer{})
	dtbCustomerMapping              = queries.MakeStructMapping(dtbCustomerType)
	dtbCustomerPrimaryKeyMapping, _ = queries.BindMapping(dtbCustomerType, dtbCustomerMapping, dtbCustomerPrimaryKeyColumns)
	dtbCustomerInsertCacheMut       sync.RWMutex
	dtbCustomerInsertCache          = make(map[string]insertCache)
	dtbCustomerUpdateCacheMut       sync.RWMutex
	dtbCustomerUpdateCache          = make(map[string]updateCache)
	dtbCustomerUpsertCacheMut       sync.RWMutex
	dtbCustomerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var dtbCustomerBeforeInsertHooks []DTBCustomerHook
var dtbCustomerBeforeUpdateHooks []DTBCustomerHook
var dtbCustomerBeforeDeleteHooks []DTBCustomerHook
var dtbCustomerBeforeUpsertHooks []DTBCustomerHook

var dtbCustomerAfterInsertHooks []DTBCustomerHook
var dtbCustomerAfterSelectHooks []DTBCustomerHook
var dtbCustomerAfterUpdateHooks []DTBCustomerHook
var dtbCustomerAfterDeleteHooks []DTBCustomerHook
var dtbCustomerAfterUpsertHooks []DTBCustomerHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DTBCustomer) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbCustomerBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DTBCustomer) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbCustomerBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DTBCustomer) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbCustomerBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DTBCustomer) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbCustomerBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DTBCustomer) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbCustomerAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DTBCustomer) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbCustomerAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DTBCustomer) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbCustomerAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DTBCustomer) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbCustomerAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DTBCustomer) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbCustomerAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDTBCustomerHook registers your hook function for all future operations.
func AddDTBCustomerHook(hookPoint boil.HookPoint, dtbCustomerHook DTBCustomerHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		dtbCustomerBeforeInsertHooks = append(dtbCustomerBeforeInsertHooks, dtbCustomerHook)
	case boil.BeforeUpdateHook:
		dtbCustomerBeforeUpdateHooks = append(dtbCustomerBeforeUpdateHooks, dtbCustomerHook)
	case boil.BeforeDeleteHook:
		dtbCustomerBeforeDeleteHooks = append(dtbCustomerBeforeDeleteHooks, dtbCustomerHook)
	case boil.BeforeUpsertHook:
		dtbCustomerBeforeUpsertHooks = append(dtbCustomerBeforeUpsertHooks, dtbCustomerHook)
	case boil.AfterInsertHook:
		dtbCustomerAfterInsertHooks = append(dtbCustomerAfterInsertHooks, dtbCustomerHook)
	case boil.AfterSelectHook:
		dtbCustomerAfterSelectHooks = append(dtbCustomerAfterSelectHooks, dtbCustomerHook)
	case boil.AfterUpdateHook:
		dtbCustomerAfterUpdateHooks = append(dtbCustomerAfterUpdateHooks, dtbCustomerHook)
	case boil.AfterDeleteHook:
		dtbCustomerAfterDeleteHooks = append(dtbCustomerAfterDeleteHooks, dtbCustomerHook)
	case boil.AfterUpsertHook:
		dtbCustomerAfterUpsertHooks = append(dtbCustomerAfterUpsertHooks, dtbCustomerHook)
	}
}

// One returns a single dtbCustomer record from the query.
func (q dtbCustomerQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DTBCustomer, error) {
	o := &DTBCustomer{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for dtb_customer")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DTBCustomer records from the query.
func (q dtbCustomerQuery) All(ctx context.Context, exec boil.ContextExecutor) (DTBCustomerSlice, error) {
	var o []*DTBCustomer

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to DTBCustomer slice")
	}

	if len(dtbCustomerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DTBCustomer records in the query.
func (q dtbCustomerQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count dtb_customer rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dtbCustomerQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if dtb_customer exists")
	}

	return count > 0, nil
}

// Sex pointed to by the foreign key.
func (o *DTBCustomer) Sex(mods ...qm.QueryMod) mtbSexQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.SexID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBSexes(queryMods...)
	queries.SetFrom(query.Query, "`mtb_sex`")

	return query
}

// Job pointed to by the foreign key.
func (o *DTBCustomer) Job(mods ...qm.QueryMod) mtbJobQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.JobID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBJobs(queryMods...)
	queries.SetFrom(query.Query, "`mtb_job`")

	return query
}

// CustomerStatus pointed to by the foreign key.
func (o *DTBCustomer) CustomerStatus(mods ...qm.QueryMod) mtbCustomerStatusQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.CustomerStatusID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBCustomerStatuses(queryMods...)
	queries.SetFrom(query.Query, "`mtb_customer_status`")

	return query
}

// Pref pointed to by the foreign key.
func (o *DTBCustomer) Pref(mods ...qm.QueryMod) mtbPrefQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.PrefID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBPrefs(queryMods...)
	queries.SetFrom(query.Query, "`mtb_pref`")

	return query
}

// Country pointed to by the foreign key.
func (o *DTBCustomer) Country(mods ...qm.QueryMod) mtbCountryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.CountryID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBCountries(queryMods...)
	queries.SetFrom(query.Query, "`mtb_country`")

	return query
}

// CustomerDTBCarts retrieves all the dtb_cart's DTBCarts with an executor via customer_id column.
func (o *DTBCustomer) CustomerDTBCarts(mods ...qm.QueryMod) dtbCartQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_cart`.`customer_id`=?", o.ID),
	)

	query := DTBCarts(queryMods...)
	queries.SetFrom(query.Query, "`dtb_cart`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_cart`.*"})
	}

	return query
}

// CustomerDTBCustomerAddresses retrieves all the dtb_customer_address's DTBCustomerAddresses with an executor via customer_id column.
func (o *DTBCustomer) CustomerDTBCustomerAddresses(mods ...qm.QueryMod) dtbCustomerAddressQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_customer_address`.`customer_id`=?", o.ID),
	)

	query := DTBCustomerAddresses(queryMods...)
	queries.SetFrom(query.Query, "`dtb_customer_address`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_customer_address`.*"})
	}

	return query
}

// CustomerDTBCustomerFavoriteProducts retrieves all the dtb_customer_favorite_product's DTBCustomerFavoriteProducts with an executor via customer_id column.
func (o *DTBCustomer) CustomerDTBCustomerFavoriteProducts(mods ...qm.QueryMod) dtbCustomerFavoriteProductQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_customer_favorite_product`.`customer_id`=?", o.ID),
	)

	query := DTBCustomerFavoriteProducts(queryMods...)
	queries.SetFrom(query.Query, "`dtb_customer_favorite_product`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_customer_favorite_product`.*"})
	}

	return query
}

// CustomerDTBOrders retrieves all the dtb_order's DTBOrders with an executor via customer_id column.
func (o *DTBCustomer) CustomerDTBOrders(mods ...qm.QueryMod) dtbOrderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_order`.`customer_id`=?", o.ID),
	)

	query := DTBOrders(queryMods...)
	queries.SetFrom(query.Query, "`dtb_order`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_order`.*"})
	}

	return query
}

// LoadSex allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbCustomerL) LoadSex(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBCustomer interface{}, mods queries.Applicator) error {
	var slice []*DTBCustomer
	var object *DTBCustomer

	if singular {
		object = maybeDTBCustomer.(*DTBCustomer)
	} else {
		slice = *maybeDTBCustomer.(*[]*DTBCustomer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbCustomerR{}
		}
		if !queries.IsNil(object.SexID) {
			args = append(args, object.SexID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbCustomerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.SexID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.SexID) {
				args = append(args, obj.SexID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_sex`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBSex")
	}

	var resultSlice []*MTBSex
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBSex")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_sex")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_sex")
	}

	if len(dtbCustomerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Sex = foreign
		if foreign.R == nil {
			foreign.R = &mtbSexR{}
		}
		foreign.R.SexDTBCustomers = append(foreign.R.SexDTBCustomers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SexID, foreign.ID) {
				local.R.Sex = foreign
				if foreign.R == nil {
					foreign.R = &mtbSexR{}
				}
				foreign.R.SexDTBCustomers = append(foreign.R.SexDTBCustomers, local)
				break
			}
		}
	}

	return nil
}

// LoadJob allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbCustomerL) LoadJob(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBCustomer interface{}, mods queries.Applicator) error {
	var slice []*DTBCustomer
	var object *DTBCustomer

	if singular {
		object = maybeDTBCustomer.(*DTBCustomer)
	} else {
		slice = *maybeDTBCustomer.(*[]*DTBCustomer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbCustomerR{}
		}
		if !queries.IsNil(object.JobID) {
			args = append(args, object.JobID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbCustomerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.JobID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.JobID) {
				args = append(args, obj.JobID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_job`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBJob")
	}

	var resultSlice []*MTBJob
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBJob")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_job")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_job")
	}

	if len(dtbCustomerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Job = foreign
		if foreign.R == nil {
			foreign.R = &mtbJobR{}
		}
		foreign.R.JobDTBCustomers = append(foreign.R.JobDTBCustomers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.JobID, foreign.ID) {
				local.R.Job = foreign
				if foreign.R == nil {
					foreign.R = &mtbJobR{}
				}
				foreign.R.JobDTBCustomers = append(foreign.R.JobDTBCustomers, local)
				break
			}
		}
	}

	return nil
}

// LoadCustomerStatus allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbCustomerL) LoadCustomerStatus(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBCustomer interface{}, mods queries.Applicator) error {
	var slice []*DTBCustomer
	var object *DTBCustomer

	if singular {
		object = maybeDTBCustomer.(*DTBCustomer)
	} else {
		slice = *maybeDTBCustomer.(*[]*DTBCustomer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbCustomerR{}
		}
		if !queries.IsNil(object.CustomerStatusID) {
			args = append(args, object.CustomerStatusID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbCustomerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CustomerStatusID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CustomerStatusID) {
				args = append(args, obj.CustomerStatusID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_customer_status`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBCustomerStatus")
	}

	var resultSlice []*MTBCustomerStatus
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBCustomerStatus")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_customer_status")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_customer_status")
	}

	if len(dtbCustomerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CustomerStatus = foreign
		if foreign.R == nil {
			foreign.R = &mtbCustomerStatusR{}
		}
		foreign.R.CustomerStatusDTBCustomers = append(foreign.R.CustomerStatusDTBCustomers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CustomerStatusID, foreign.ID) {
				local.R.CustomerStatus = foreign
				if foreign.R == nil {
					foreign.R = &mtbCustomerStatusR{}
				}
				foreign.R.CustomerStatusDTBCustomers = append(foreign.R.CustomerStatusDTBCustomers, local)
				break
			}
		}
	}

	return nil
}

// LoadPref allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbCustomerL) LoadPref(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBCustomer interface{}, mods queries.Applicator) error {
	var slice []*DTBCustomer
	var object *DTBCustomer

	if singular {
		object = maybeDTBCustomer.(*DTBCustomer)
	} else {
		slice = *maybeDTBCustomer.(*[]*DTBCustomer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbCustomerR{}
		}
		if !queries.IsNil(object.PrefID) {
			args = append(args, object.PrefID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbCustomerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PrefID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PrefID) {
				args = append(args, obj.PrefID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_pref`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBPref")
	}

	var resultSlice []*MTBPref
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBPref")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_pref")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_pref")
	}

	if len(dtbCustomerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Pref = foreign
		if foreign.R == nil {
			foreign.R = &mtbPrefR{}
		}
		foreign.R.PrefDTBCustomers = append(foreign.R.PrefDTBCustomers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PrefID, foreign.ID) {
				local.R.Pref = foreign
				if foreign.R == nil {
					foreign.R = &mtbPrefR{}
				}
				foreign.R.PrefDTBCustomers = append(foreign.R.PrefDTBCustomers, local)
				break
			}
		}
	}

	return nil
}

// LoadCountry allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbCustomerL) LoadCountry(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBCustomer interface{}, mods queries.Applicator) error {
	var slice []*DTBCustomer
	var object *DTBCustomer

	if singular {
		object = maybeDTBCustomer.(*DTBCustomer)
	} else {
		slice = *maybeDTBCustomer.(*[]*DTBCustomer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbCustomerR{}
		}
		if !queries.IsNil(object.CountryID) {
			args = append(args, object.CountryID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbCustomerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CountryID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CountryID) {
				args = append(args, obj.CountryID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_country`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBCountry")
	}

	var resultSlice []*MTBCountry
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBCountry")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_country")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_country")
	}

	if len(dtbCustomerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Country = foreign
		if foreign.R == nil {
			foreign.R = &mtbCountryR{}
		}
		foreign.R.CountryDTBCustomers = append(foreign.R.CountryDTBCustomers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CountryID, foreign.ID) {
				local.R.Country = foreign
				if foreign.R == nil {
					foreign.R = &mtbCountryR{}
				}
				foreign.R.CountryDTBCustomers = append(foreign.R.CountryDTBCustomers, local)
				break
			}
		}
	}

	return nil
}

// LoadCustomerDTBCarts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbCustomerL) LoadCustomerDTBCarts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBCustomer interface{}, mods queries.Applicator) error {
	var slice []*DTBCustomer
	var object *DTBCustomer

	if singular {
		object = maybeDTBCustomer.(*DTBCustomer)
	} else {
		slice = *maybeDTBCustomer.(*[]*DTBCustomer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbCustomerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbCustomerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_cart`), qm.WhereIn(`customer_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_cart")
	}

	var resultSlice []*DTBCart
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_cart")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_cart")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_cart")
	}

	if len(dtbCartAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CustomerDTBCarts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbCartR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CustomerID) {
				local.R.CustomerDTBCarts = append(local.R.CustomerDTBCarts, foreign)
				if foreign.R == nil {
					foreign.R = &dtbCartR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadCustomerDTBCustomerAddresses allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbCustomerL) LoadCustomerDTBCustomerAddresses(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBCustomer interface{}, mods queries.Applicator) error {
	var slice []*DTBCustomer
	var object *DTBCustomer

	if singular {
		object = maybeDTBCustomer.(*DTBCustomer)
	} else {
		slice = *maybeDTBCustomer.(*[]*DTBCustomer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbCustomerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbCustomerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_customer_address`), qm.WhereIn(`customer_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_customer_address")
	}

	var resultSlice []*DTBCustomerAddress
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_customer_address")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_customer_address")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_customer_address")
	}

	if len(dtbCustomerAddressAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CustomerDTBCustomerAddresses = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbCustomerAddressR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CustomerID) {
				local.R.CustomerDTBCustomerAddresses = append(local.R.CustomerDTBCustomerAddresses, foreign)
				if foreign.R == nil {
					foreign.R = &dtbCustomerAddressR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadCustomerDTBCustomerFavoriteProducts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbCustomerL) LoadCustomerDTBCustomerFavoriteProducts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBCustomer interface{}, mods queries.Applicator) error {
	var slice []*DTBCustomer
	var object *DTBCustomer

	if singular {
		object = maybeDTBCustomer.(*DTBCustomer)
	} else {
		slice = *maybeDTBCustomer.(*[]*DTBCustomer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbCustomerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbCustomerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_customer_favorite_product`), qm.WhereIn(`customer_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_customer_favorite_product")
	}

	var resultSlice []*DTBCustomerFavoriteProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_customer_favorite_product")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_customer_favorite_product")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_customer_favorite_product")
	}

	if len(dtbCustomerFavoriteProductAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CustomerDTBCustomerFavoriteProducts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbCustomerFavoriteProductR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CustomerID) {
				local.R.CustomerDTBCustomerFavoriteProducts = append(local.R.CustomerDTBCustomerFavoriteProducts, foreign)
				if foreign.R == nil {
					foreign.R = &dtbCustomerFavoriteProductR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadCustomerDTBOrders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbCustomerL) LoadCustomerDTBOrders(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBCustomer interface{}, mods queries.Applicator) error {
	var slice []*DTBCustomer
	var object *DTBCustomer

	if singular {
		object = maybeDTBCustomer.(*DTBCustomer)
	} else {
		slice = *maybeDTBCustomer.(*[]*DTBCustomer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbCustomerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbCustomerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_order`), qm.WhereIn(`customer_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_order")
	}

	var resultSlice []*DTBOrder
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_order")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_order")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_order")
	}

	if len(dtbOrderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CustomerDTBOrders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbOrderR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CustomerID) {
				local.R.CustomerDTBOrders = append(local.R.CustomerDTBOrders, foreign)
				if foreign.R == nil {
					foreign.R = &dtbOrderR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// SetSex of the dtbCustomer to the related item.
// Sets o.R.Sex to related.
// Adds o to related.R.SexDTBCustomers.
func (o *DTBCustomer) SetSex(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBSex) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_customer` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"sex_id"}),
		strmangle.WhereClause("`", "`", 0, dtbCustomerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SexID, related.ID)
	if o.R == nil {
		o.R = &dtbCustomerR{
			Sex: related,
		}
	} else {
		o.R.Sex = related
	}

	if related.R == nil {
		related.R = &mtbSexR{
			SexDTBCustomers: DTBCustomerSlice{o},
		}
	} else {
		related.R.SexDTBCustomers = append(related.R.SexDTBCustomers, o)
	}

	return nil
}

// RemoveSex relationship.
// Sets o.R.Sex to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBCustomer) RemoveSex(ctx context.Context, exec boil.ContextExecutor, related *MTBSex) error {
	var err error

	queries.SetScanner(&o.SexID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("sex_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Sex = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.SexDTBCustomers {
		if queries.Equal(o.SexID, ri.SexID) {
			continue
		}

		ln := len(related.R.SexDTBCustomers)
		if ln > 1 && i < ln-1 {
			related.R.SexDTBCustomers[i] = related.R.SexDTBCustomers[ln-1]
		}
		related.R.SexDTBCustomers = related.R.SexDTBCustomers[:ln-1]
		break
	}
	return nil
}

// SetJob of the dtbCustomer to the related item.
// Sets o.R.Job to related.
// Adds o to related.R.JobDTBCustomers.
func (o *DTBCustomer) SetJob(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBJob) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_customer` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"job_id"}),
		strmangle.WhereClause("`", "`", 0, dtbCustomerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.JobID, related.ID)
	if o.R == nil {
		o.R = &dtbCustomerR{
			Job: related,
		}
	} else {
		o.R.Job = related
	}

	if related.R == nil {
		related.R = &mtbJobR{
			JobDTBCustomers: DTBCustomerSlice{o},
		}
	} else {
		related.R.JobDTBCustomers = append(related.R.JobDTBCustomers, o)
	}

	return nil
}

// RemoveJob relationship.
// Sets o.R.Job to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBCustomer) RemoveJob(ctx context.Context, exec boil.ContextExecutor, related *MTBJob) error {
	var err error

	queries.SetScanner(&o.JobID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("job_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Job = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.JobDTBCustomers {
		if queries.Equal(o.JobID, ri.JobID) {
			continue
		}

		ln := len(related.R.JobDTBCustomers)
		if ln > 1 && i < ln-1 {
			related.R.JobDTBCustomers[i] = related.R.JobDTBCustomers[ln-1]
		}
		related.R.JobDTBCustomers = related.R.JobDTBCustomers[:ln-1]
		break
	}
	return nil
}

// SetCustomerStatus of the dtbCustomer to the related item.
// Sets o.R.CustomerStatus to related.
// Adds o to related.R.CustomerStatusDTBCustomers.
func (o *DTBCustomer) SetCustomerStatus(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBCustomerStatus) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_customer` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"customer_status_id"}),
		strmangle.WhereClause("`", "`", 0, dtbCustomerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CustomerStatusID, related.ID)
	if o.R == nil {
		o.R = &dtbCustomerR{
			CustomerStatus: related,
		}
	} else {
		o.R.CustomerStatus = related
	}

	if related.R == nil {
		related.R = &mtbCustomerStatusR{
			CustomerStatusDTBCustomers: DTBCustomerSlice{o},
		}
	} else {
		related.R.CustomerStatusDTBCustomers = append(related.R.CustomerStatusDTBCustomers, o)
	}

	return nil
}

// RemoveCustomerStatus relationship.
// Sets o.R.CustomerStatus to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBCustomer) RemoveCustomerStatus(ctx context.Context, exec boil.ContextExecutor, related *MTBCustomerStatus) error {
	var err error

	queries.SetScanner(&o.CustomerStatusID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("customer_status_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.CustomerStatus = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CustomerStatusDTBCustomers {
		if queries.Equal(o.CustomerStatusID, ri.CustomerStatusID) {
			continue
		}

		ln := len(related.R.CustomerStatusDTBCustomers)
		if ln > 1 && i < ln-1 {
			related.R.CustomerStatusDTBCustomers[i] = related.R.CustomerStatusDTBCustomers[ln-1]
		}
		related.R.CustomerStatusDTBCustomers = related.R.CustomerStatusDTBCustomers[:ln-1]
		break
	}
	return nil
}

// SetPref of the dtbCustomer to the related item.
// Sets o.R.Pref to related.
// Adds o to related.R.PrefDTBCustomers.
func (o *DTBCustomer) SetPref(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBPref) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_customer` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"pref_id"}),
		strmangle.WhereClause("`", "`", 0, dtbCustomerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PrefID, related.ID)
	if o.R == nil {
		o.R = &dtbCustomerR{
			Pref: related,
		}
	} else {
		o.R.Pref = related
	}

	if related.R == nil {
		related.R = &mtbPrefR{
			PrefDTBCustomers: DTBCustomerSlice{o},
		}
	} else {
		related.R.PrefDTBCustomers = append(related.R.PrefDTBCustomers, o)
	}

	return nil
}

// RemovePref relationship.
// Sets o.R.Pref to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBCustomer) RemovePref(ctx context.Context, exec boil.ContextExecutor, related *MTBPref) error {
	var err error

	queries.SetScanner(&o.PrefID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("pref_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Pref = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PrefDTBCustomers {
		if queries.Equal(o.PrefID, ri.PrefID) {
			continue
		}

		ln := len(related.R.PrefDTBCustomers)
		if ln > 1 && i < ln-1 {
			related.R.PrefDTBCustomers[i] = related.R.PrefDTBCustomers[ln-1]
		}
		related.R.PrefDTBCustomers = related.R.PrefDTBCustomers[:ln-1]
		break
	}
	return nil
}

// SetCountry of the dtbCustomer to the related item.
// Sets o.R.Country to related.
// Adds o to related.R.CountryDTBCustomers.
func (o *DTBCustomer) SetCountry(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBCountry) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_customer` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"country_id"}),
		strmangle.WhereClause("`", "`", 0, dtbCustomerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CountryID, related.ID)
	if o.R == nil {
		o.R = &dtbCustomerR{
			Country: related,
		}
	} else {
		o.R.Country = related
	}

	if related.R == nil {
		related.R = &mtbCountryR{
			CountryDTBCustomers: DTBCustomerSlice{o},
		}
	} else {
		related.R.CountryDTBCustomers = append(related.R.CountryDTBCustomers, o)
	}

	return nil
}

// RemoveCountry relationship.
// Sets o.R.Country to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBCustomer) RemoveCountry(ctx context.Context, exec boil.ContextExecutor, related *MTBCountry) error {
	var err error

	queries.SetScanner(&o.CountryID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("country_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Country = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CountryDTBCustomers {
		if queries.Equal(o.CountryID, ri.CountryID) {
			continue
		}

		ln := len(related.R.CountryDTBCustomers)
		if ln > 1 && i < ln-1 {
			related.R.CountryDTBCustomers[i] = related.R.CountryDTBCustomers[ln-1]
		}
		related.R.CountryDTBCustomers = related.R.CountryDTBCustomers[:ln-1]
		break
	}
	return nil
}

// AddCustomerDTBCarts adds the given related objects to the existing relationships
// of the dtb_customer, optionally inserting them as new records.
// Appends related to o.R.CustomerDTBCarts.
// Sets related.R.Customer appropriately.
func (o *DTBCustomer) AddCustomerDTBCarts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCart) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CustomerID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_cart` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"customer_id"}),
				strmangle.WhereClause("`", "`", 0, dtbCartPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CustomerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbCustomerR{
			CustomerDTBCarts: related,
		}
	} else {
		o.R.CustomerDTBCarts = append(o.R.CustomerDTBCarts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbCartR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// SetCustomerDTBCarts removes all previously related items of the
// dtb_customer replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Customer's CustomerDTBCarts accordingly.
// Replaces o.R.CustomerDTBCarts with related.
// Sets related.R.Customer's CustomerDTBCarts accordingly.
func (o *DTBCustomer) SetCustomerDTBCarts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCart) error {
	query := "update `dtb_cart` set `customer_id` = null where `customer_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CustomerDTBCarts {
			queries.SetScanner(&rel.CustomerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Customer = nil
		}

		o.R.CustomerDTBCarts = nil
	}
	return o.AddCustomerDTBCarts(ctx, exec, insert, related...)
}

// RemoveCustomerDTBCarts relationships from objects passed in.
// Removes related items from R.CustomerDTBCarts (uses pointer comparison, removal does not keep order)
// Sets related.R.Customer.
func (o *DTBCustomer) RemoveCustomerDTBCarts(ctx context.Context, exec boil.ContextExecutor, related ...*DTBCart) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CustomerID, nil)
		if rel.R != nil {
			rel.R.Customer = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("customer_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CustomerDTBCarts {
			if rel != ri {
				continue
			}

			ln := len(o.R.CustomerDTBCarts)
			if ln > 1 && i < ln-1 {
				o.R.CustomerDTBCarts[i] = o.R.CustomerDTBCarts[ln-1]
			}
			o.R.CustomerDTBCarts = o.R.CustomerDTBCarts[:ln-1]
			break
		}
	}

	return nil
}

// AddCustomerDTBCustomerAddresses adds the given related objects to the existing relationships
// of the dtb_customer, optionally inserting them as new records.
// Appends related to o.R.CustomerDTBCustomerAddresses.
// Sets related.R.Customer appropriately.
func (o *DTBCustomer) AddCustomerDTBCustomerAddresses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCustomerAddress) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CustomerID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_customer_address` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"customer_id"}),
				strmangle.WhereClause("`", "`", 0, dtbCustomerAddressPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CustomerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbCustomerR{
			CustomerDTBCustomerAddresses: related,
		}
	} else {
		o.R.CustomerDTBCustomerAddresses = append(o.R.CustomerDTBCustomerAddresses, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbCustomerAddressR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// SetCustomerDTBCustomerAddresses removes all previously related items of the
// dtb_customer replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Customer's CustomerDTBCustomerAddresses accordingly.
// Replaces o.R.CustomerDTBCustomerAddresses with related.
// Sets related.R.Customer's CustomerDTBCustomerAddresses accordingly.
func (o *DTBCustomer) SetCustomerDTBCustomerAddresses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCustomerAddress) error {
	query := "update `dtb_customer_address` set `customer_id` = null where `customer_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CustomerDTBCustomerAddresses {
			queries.SetScanner(&rel.CustomerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Customer = nil
		}

		o.R.CustomerDTBCustomerAddresses = nil
	}
	return o.AddCustomerDTBCustomerAddresses(ctx, exec, insert, related...)
}

// RemoveCustomerDTBCustomerAddresses relationships from objects passed in.
// Removes related items from R.CustomerDTBCustomerAddresses (uses pointer comparison, removal does not keep order)
// Sets related.R.Customer.
func (o *DTBCustomer) RemoveCustomerDTBCustomerAddresses(ctx context.Context, exec boil.ContextExecutor, related ...*DTBCustomerAddress) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CustomerID, nil)
		if rel.R != nil {
			rel.R.Customer = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("customer_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CustomerDTBCustomerAddresses {
			if rel != ri {
				continue
			}

			ln := len(o.R.CustomerDTBCustomerAddresses)
			if ln > 1 && i < ln-1 {
				o.R.CustomerDTBCustomerAddresses[i] = o.R.CustomerDTBCustomerAddresses[ln-1]
			}
			o.R.CustomerDTBCustomerAddresses = o.R.CustomerDTBCustomerAddresses[:ln-1]
			break
		}
	}

	return nil
}

// AddCustomerDTBCustomerFavoriteProducts adds the given related objects to the existing relationships
// of the dtb_customer, optionally inserting them as new records.
// Appends related to o.R.CustomerDTBCustomerFavoriteProducts.
// Sets related.R.Customer appropriately.
func (o *DTBCustomer) AddCustomerDTBCustomerFavoriteProducts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCustomerFavoriteProduct) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CustomerID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_customer_favorite_product` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"customer_id"}),
				strmangle.WhereClause("`", "`", 0, dtbCustomerFavoriteProductPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CustomerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbCustomerR{
			CustomerDTBCustomerFavoriteProducts: related,
		}
	} else {
		o.R.CustomerDTBCustomerFavoriteProducts = append(o.R.CustomerDTBCustomerFavoriteProducts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbCustomerFavoriteProductR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// SetCustomerDTBCustomerFavoriteProducts removes all previously related items of the
// dtb_customer replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Customer's CustomerDTBCustomerFavoriteProducts accordingly.
// Replaces o.R.CustomerDTBCustomerFavoriteProducts with related.
// Sets related.R.Customer's CustomerDTBCustomerFavoriteProducts accordingly.
func (o *DTBCustomer) SetCustomerDTBCustomerFavoriteProducts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCustomerFavoriteProduct) error {
	query := "update `dtb_customer_favorite_product` set `customer_id` = null where `customer_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CustomerDTBCustomerFavoriteProducts {
			queries.SetScanner(&rel.CustomerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Customer = nil
		}

		o.R.CustomerDTBCustomerFavoriteProducts = nil
	}
	return o.AddCustomerDTBCustomerFavoriteProducts(ctx, exec, insert, related...)
}

// RemoveCustomerDTBCustomerFavoriteProducts relationships from objects passed in.
// Removes related items from R.CustomerDTBCustomerFavoriteProducts (uses pointer comparison, removal does not keep order)
// Sets related.R.Customer.
func (o *DTBCustomer) RemoveCustomerDTBCustomerFavoriteProducts(ctx context.Context, exec boil.ContextExecutor, related ...*DTBCustomerFavoriteProduct) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CustomerID, nil)
		if rel.R != nil {
			rel.R.Customer = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("customer_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CustomerDTBCustomerFavoriteProducts {
			if rel != ri {
				continue
			}

			ln := len(o.R.CustomerDTBCustomerFavoriteProducts)
			if ln > 1 && i < ln-1 {
				o.R.CustomerDTBCustomerFavoriteProducts[i] = o.R.CustomerDTBCustomerFavoriteProducts[ln-1]
			}
			o.R.CustomerDTBCustomerFavoriteProducts = o.R.CustomerDTBCustomerFavoriteProducts[:ln-1]
			break
		}
	}

	return nil
}

// AddCustomerDTBOrders adds the given related objects to the existing relationships
// of the dtb_customer, optionally inserting them as new records.
// Appends related to o.R.CustomerDTBOrders.
// Sets related.R.Customer appropriately.
func (o *DTBCustomer) AddCustomerDTBOrders(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBOrder) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CustomerID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_order` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"customer_id"}),
				strmangle.WhereClause("`", "`", 0, dtbOrderPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CustomerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbCustomerR{
			CustomerDTBOrders: related,
		}
	} else {
		o.R.CustomerDTBOrders = append(o.R.CustomerDTBOrders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbOrderR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// SetCustomerDTBOrders removes all previously related items of the
// dtb_customer replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Customer's CustomerDTBOrders accordingly.
// Replaces o.R.CustomerDTBOrders with related.
// Sets related.R.Customer's CustomerDTBOrders accordingly.
func (o *DTBCustomer) SetCustomerDTBOrders(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBOrder) error {
	query := "update `dtb_order` set `customer_id` = null where `customer_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CustomerDTBOrders {
			queries.SetScanner(&rel.CustomerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Customer = nil
		}

		o.R.CustomerDTBOrders = nil
	}
	return o.AddCustomerDTBOrders(ctx, exec, insert, related...)
}

// RemoveCustomerDTBOrders relationships from objects passed in.
// Removes related items from R.CustomerDTBOrders (uses pointer comparison, removal does not keep order)
// Sets related.R.Customer.
func (o *DTBCustomer) RemoveCustomerDTBOrders(ctx context.Context, exec boil.ContextExecutor, related ...*DTBOrder) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CustomerID, nil)
		if rel.R != nil {
			rel.R.Customer = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("customer_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CustomerDTBOrders {
			if rel != ri {
				continue
			}

			ln := len(o.R.CustomerDTBOrders)
			if ln > 1 && i < ln-1 {
				o.R.CustomerDTBOrders[i] = o.R.CustomerDTBOrders[ln-1]
			}
			o.R.CustomerDTBOrders = o.R.CustomerDTBOrders[:ln-1]
			break
		}
	}

	return nil
}

// DTBCustomers retrieves all the records using an executor.
func DTBCustomers(mods ...qm.QueryMod) dtbCustomerQuery {
	mods = append(mods, qm.From("`dtb_customer`"))
	return dtbCustomerQuery{NewQuery(mods...)}
}

// FindDTBCustomer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDTBCustomer(ctx context.Context, exec boil.ContextExecutor, iD uint, selectCols ...string) (*DTBCustomer, error) {
	dtbCustomerObj := &DTBCustomer{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `dtb_customer` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, dtbCustomerObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from dtb_customer")
	}

	return dtbCustomerObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DTBCustomer) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_customer provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbCustomerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dtbCustomerInsertCacheMut.RLock()
	cache, cached := dtbCustomerInsertCache[key]
	dtbCustomerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dtbCustomerColumns,
			dtbCustomerColumnsWithDefault,
			dtbCustomerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dtbCustomerType, dtbCustomerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dtbCustomerType, dtbCustomerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `dtb_customer` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `dtb_customer` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `dtb_customer` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dtbCustomerPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into dtb_customer")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbCustomerMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_customer")
	}

CacheNoHooks:
	if !cached {
		dtbCustomerInsertCacheMut.Lock()
		dtbCustomerInsertCache[key] = cache
		dtbCustomerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DTBCustomer.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DTBCustomer) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	dtbCustomerUpdateCacheMut.RLock()
	cache, cached := dtbCustomerUpdateCache[key]
	dtbCustomerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dtbCustomerColumns,
			dtbCustomerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("model: unable to update dtb_customer, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `dtb_customer` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dtbCustomerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dtbCustomerType, dtbCustomerMapping, append(wl, dtbCustomerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update dtb_customer row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by update for dtb_customer")
	}

	if !cached {
		dtbCustomerUpdateCacheMut.Lock()
		dtbCustomerUpdateCache[key] = cache
		dtbCustomerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q dtbCustomerQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all for dtb_customer")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected for dtb_customer")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DTBCustomerSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbCustomerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `dtb_customer` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbCustomerPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all in dtbCustomer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected all in update all dtbCustomer")
	}
	return rowsAff, nil
}

var mySQLDTBCustomerUniqueColumns = []string{
	"id",
	"secret_key",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DTBCustomer) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_customer provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbCustomerColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDTBCustomerUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dtbCustomerUpsertCacheMut.RLock()
	cache, cached := dtbCustomerUpsertCache[key]
	dtbCustomerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dtbCustomerColumns,
			dtbCustomerColumnsWithDefault,
			dtbCustomerColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			dtbCustomerColumns,
			dtbCustomerPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("model: unable to upsert dtb_customer, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "dtb_customer", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `dtb_customer` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dtbCustomerType, dtbCustomerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dtbCustomerType, dtbCustomerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to upsert for dtb_customer")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbCustomerMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dtbCustomerType, dtbCustomerMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "model: unable to retrieve unique values for dtb_customer")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_customer")
	}

CacheNoHooks:
	if !cached {
		dtbCustomerUpsertCacheMut.Lock()
		dtbCustomerUpsertCache[key] = cache
		dtbCustomerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DTBCustomer record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DTBCustomer) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBCustomer provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dtbCustomerPrimaryKeyMapping)
	sql := "DELETE FROM `dtb_customer` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete from dtb_customer")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by delete for dtb_customer")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q dtbCustomerQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("model: no dtbCustomerQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtb_customer")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_customer")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DTBCustomerSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBCustomer slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(dtbCustomerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbCustomerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `dtb_customer` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbCustomerPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtbCustomer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_customer")
	}

	if len(dtbCustomerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DTBCustomer) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDTBCustomer(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DTBCustomerSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DTBCustomerSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbCustomerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `dtb_customer`.* FROM `dtb_customer` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbCustomerPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in DTBCustomerSlice")
	}

	*o = slice

	return nil
}

// DTBCustomerExists checks if the DTBCustomer row exists.
func DTBCustomerExists(ctx context.Context, exec boil.ContextExecutor, iD uint) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `dtb_customer` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if dtb_customer exists")
	}

	return exists, nil
}
