// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// DTBOrder is an object representing the database table.
type DTBOrder struct {
	ID                  uint          `boil:"id" json:"id" toml:"id" yaml:"id"`
	CustomerID          null.Uint     `boil:"customer_id" json:"customer_id,omitempty" toml:"customer_id" yaml:"customer_id,omitempty"`
	CountryID           null.Uint16   `boil:"country_id" json:"country_id,omitempty" toml:"country_id" yaml:"country_id,omitempty"`
	PrefID              null.Uint16   `boil:"pref_id" json:"pref_id,omitempty" toml:"pref_id" yaml:"pref_id,omitempty"`
	SexID               null.Uint16   `boil:"sex_id" json:"sex_id,omitempty" toml:"sex_id" yaml:"sex_id,omitempty"`
	JobID               null.Uint16   `boil:"job_id" json:"job_id,omitempty" toml:"job_id" yaml:"job_id,omitempty"`
	PaymentID           null.Uint     `boil:"payment_id" json:"payment_id,omitempty" toml:"payment_id" yaml:"payment_id,omitempty"`
	DeviceTypeID        null.Uint16   `boil:"device_type_id" json:"device_type_id,omitempty" toml:"device_type_id" yaml:"device_type_id,omitempty"`
	PreOrderID          null.String   `boil:"pre_order_id" json:"pre_order_id,omitempty" toml:"pre_order_id" yaml:"pre_order_id,omitempty"`
	OrderNo             null.String   `boil:"order_no" json:"order_no,omitempty" toml:"order_no" yaml:"order_no,omitempty"`
	Message             null.String   `boil:"message" json:"message,omitempty" toml:"message" yaml:"message,omitempty"`
	Name01              string        `boil:"name01" json:"name01" toml:"name01" yaml:"name01"`
	Name02              string        `boil:"name02" json:"name02" toml:"name02" yaml:"name02"`
	Kana01              null.String   `boil:"kana01" json:"kana01,omitempty" toml:"kana01" yaml:"kana01,omitempty"`
	Kana02              null.String   `boil:"kana02" json:"kana02,omitempty" toml:"kana02" yaml:"kana02,omitempty"`
	CompanyName         null.String   `boil:"company_name" json:"company_name,omitempty" toml:"company_name" yaml:"company_name,omitempty"`
	Email               null.String   `boil:"email" json:"email,omitempty" toml:"email" yaml:"email,omitempty"`
	PhoneNumber         null.String   `boil:"phone_number" json:"phone_number,omitempty" toml:"phone_number" yaml:"phone_number,omitempty"`
	PostalCode          null.String   `boil:"postal_code" json:"postal_code,omitempty" toml:"postal_code" yaml:"postal_code,omitempty"`
	Addr01              null.String   `boil:"addr01" json:"addr01,omitempty" toml:"addr01" yaml:"addr01,omitempty"`
	Addr02              null.String   `boil:"addr02" json:"addr02,omitempty" toml:"addr02" yaml:"addr02,omitempty"`
	Birth               null.Time     `boil:"birth" json:"birth,omitempty" toml:"birth" yaml:"birth,omitempty"`
	Subtotal            types.Decimal `boil:"subtotal" json:"subtotal" toml:"subtotal" yaml:"subtotal"`
	Discount            types.Decimal `boil:"discount" json:"discount" toml:"discount" yaml:"discount"`
	DeliveryFeeTotal    types.Decimal `boil:"delivery_fee_total" json:"delivery_fee_total" toml:"delivery_fee_total" yaml:"delivery_fee_total"`
	Charge              types.Decimal `boil:"charge" json:"charge" toml:"charge" yaml:"charge"`
	Tax                 types.Decimal `boil:"tax" json:"tax" toml:"tax" yaml:"tax"`
	Total               types.Decimal `boil:"total" json:"total" toml:"total" yaml:"total"`
	PaymentTotal        types.Decimal `boil:"payment_total" json:"payment_total" toml:"payment_total" yaml:"payment_total"`
	PaymentMethod       null.String   `boil:"payment_method" json:"payment_method,omitempty" toml:"payment_method" yaml:"payment_method,omitempty"`
	Note                null.String   `boil:"note" json:"note,omitempty" toml:"note" yaml:"note,omitempty"`
	CreateDate          time.Time     `boil:"create_date" json:"create_date" toml:"create_date" yaml:"create_date"`
	UpdateDate          time.Time     `boil:"update_date" json:"update_date" toml:"update_date" yaml:"update_date"`
	OrderDate           null.Time     `boil:"order_date" json:"order_date,omitempty" toml:"order_date" yaml:"order_date,omitempty"`
	PaymentDate         null.Time     `boil:"payment_date" json:"payment_date,omitempty" toml:"payment_date" yaml:"payment_date,omitempty"`
	CurrencyCode        null.String   `boil:"currency_code" json:"currency_code,omitempty" toml:"currency_code" yaml:"currency_code,omitempty"`
	CompleteMessage     null.String   `boil:"complete_message" json:"complete_message,omitempty" toml:"complete_message" yaml:"complete_message,omitempty"`
	CompleteMailMessage null.String   `boil:"complete_mail_message" json:"complete_mail_message,omitempty" toml:"complete_mail_message" yaml:"complete_mail_message,omitempty"`
	AddPoint            types.Decimal `boil:"add_point" json:"add_point" toml:"add_point" yaml:"add_point"`
	UsePoint            types.Decimal `boil:"use_point" json:"use_point" toml:"use_point" yaml:"use_point"`
	OrderStatusID       null.Uint16   `boil:"order_status_id" json:"order_status_id,omitempty" toml:"order_status_id" yaml:"order_status_id,omitempty"`
	DiscriminatorType   string        `boil:"discriminator_type" json:"discriminator_type" toml:"discriminator_type" yaml:"discriminator_type"`

	R *dtbOrderR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dtbOrderL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DTBOrderColumns = struct {
	ID                  string
	CustomerID          string
	CountryID           string
	PrefID              string
	SexID               string
	JobID               string
	PaymentID           string
	DeviceTypeID        string
	PreOrderID          string
	OrderNo             string
	Message             string
	Name01              string
	Name02              string
	Kana01              string
	Kana02              string
	CompanyName         string
	Email               string
	PhoneNumber         string
	PostalCode          string
	Addr01              string
	Addr02              string
	Birth               string
	Subtotal            string
	Discount            string
	DeliveryFeeTotal    string
	Charge              string
	Tax                 string
	Total               string
	PaymentTotal        string
	PaymentMethod       string
	Note                string
	CreateDate          string
	UpdateDate          string
	OrderDate           string
	PaymentDate         string
	CurrencyCode        string
	CompleteMessage     string
	CompleteMailMessage string
	AddPoint            string
	UsePoint            string
	OrderStatusID       string
	DiscriminatorType   string
}{
	ID:                  "id",
	CustomerID:          "customer_id",
	CountryID:           "country_id",
	PrefID:              "pref_id",
	SexID:               "sex_id",
	JobID:               "job_id",
	PaymentID:           "payment_id",
	DeviceTypeID:        "device_type_id",
	PreOrderID:          "pre_order_id",
	OrderNo:             "order_no",
	Message:             "message",
	Name01:              "name01",
	Name02:              "name02",
	Kana01:              "kana01",
	Kana02:              "kana02",
	CompanyName:         "company_name",
	Email:               "email",
	PhoneNumber:         "phone_number",
	PostalCode:          "postal_code",
	Addr01:              "addr01",
	Addr02:              "addr02",
	Birth:               "birth",
	Subtotal:            "subtotal",
	Discount:            "discount",
	DeliveryFeeTotal:    "delivery_fee_total",
	Charge:              "charge",
	Tax:                 "tax",
	Total:               "total",
	PaymentTotal:        "payment_total",
	PaymentMethod:       "payment_method",
	Note:                "note",
	CreateDate:          "create_date",
	UpdateDate:          "update_date",
	OrderDate:           "order_date",
	PaymentDate:         "payment_date",
	CurrencyCode:        "currency_code",
	CompleteMessage:     "complete_message",
	CompleteMailMessage: "complete_mail_message",
	AddPoint:            "add_point",
	UsePoint:            "use_point",
	OrderStatusID:       "order_status_id",
	DiscriminatorType:   "discriminator_type",
}

// Generated where

var DTBOrderWhere = struct {
	ID                  whereHelperuint
	CustomerID          whereHelpernull_Uint
	CountryID           whereHelpernull_Uint16
	PrefID              whereHelpernull_Uint16
	SexID               whereHelpernull_Uint16
	JobID               whereHelpernull_Uint16
	PaymentID           whereHelpernull_Uint
	DeviceTypeID        whereHelpernull_Uint16
	PreOrderID          whereHelpernull_String
	OrderNo             whereHelpernull_String
	Message             whereHelpernull_String
	Name01              whereHelperstring
	Name02              whereHelperstring
	Kana01              whereHelpernull_String
	Kana02              whereHelpernull_String
	CompanyName         whereHelpernull_String
	Email               whereHelpernull_String
	PhoneNumber         whereHelpernull_String
	PostalCode          whereHelpernull_String
	Addr01              whereHelpernull_String
	Addr02              whereHelpernull_String
	Birth               whereHelpernull_Time
	Subtotal            whereHelpertypes_Decimal
	Discount            whereHelpertypes_Decimal
	DeliveryFeeTotal    whereHelpertypes_Decimal
	Charge              whereHelpertypes_Decimal
	Tax                 whereHelpertypes_Decimal
	Total               whereHelpertypes_Decimal
	PaymentTotal        whereHelpertypes_Decimal
	PaymentMethod       whereHelpernull_String
	Note                whereHelpernull_String
	CreateDate          whereHelpertime_Time
	UpdateDate          whereHelpertime_Time
	OrderDate           whereHelpernull_Time
	PaymentDate         whereHelpernull_Time
	CurrencyCode        whereHelpernull_String
	CompleteMessage     whereHelpernull_String
	CompleteMailMessage whereHelpernull_String
	AddPoint            whereHelpertypes_Decimal
	UsePoint            whereHelpertypes_Decimal
	OrderStatusID       whereHelpernull_Uint16
	DiscriminatorType   whereHelperstring
}{
	ID:                  whereHelperuint{field: `id`},
	CustomerID:          whereHelpernull_Uint{field: `customer_id`},
	CountryID:           whereHelpernull_Uint16{field: `country_id`},
	PrefID:              whereHelpernull_Uint16{field: `pref_id`},
	SexID:               whereHelpernull_Uint16{field: `sex_id`},
	JobID:               whereHelpernull_Uint16{field: `job_id`},
	PaymentID:           whereHelpernull_Uint{field: `payment_id`},
	DeviceTypeID:        whereHelpernull_Uint16{field: `device_type_id`},
	PreOrderID:          whereHelpernull_String{field: `pre_order_id`},
	OrderNo:             whereHelpernull_String{field: `order_no`},
	Message:             whereHelpernull_String{field: `message`},
	Name01:              whereHelperstring{field: `name01`},
	Name02:              whereHelperstring{field: `name02`},
	Kana01:              whereHelpernull_String{field: `kana01`},
	Kana02:              whereHelpernull_String{field: `kana02`},
	CompanyName:         whereHelpernull_String{field: `company_name`},
	Email:               whereHelpernull_String{field: `email`},
	PhoneNumber:         whereHelpernull_String{field: `phone_number`},
	PostalCode:          whereHelpernull_String{field: `postal_code`},
	Addr01:              whereHelpernull_String{field: `addr01`},
	Addr02:              whereHelpernull_String{field: `addr02`},
	Birth:               whereHelpernull_Time{field: `birth`},
	Subtotal:            whereHelpertypes_Decimal{field: `subtotal`},
	Discount:            whereHelpertypes_Decimal{field: `discount`},
	DeliveryFeeTotal:    whereHelpertypes_Decimal{field: `delivery_fee_total`},
	Charge:              whereHelpertypes_Decimal{field: `charge`},
	Tax:                 whereHelpertypes_Decimal{field: `tax`},
	Total:               whereHelpertypes_Decimal{field: `total`},
	PaymentTotal:        whereHelpertypes_Decimal{field: `payment_total`},
	PaymentMethod:       whereHelpernull_String{field: `payment_method`},
	Note:                whereHelpernull_String{field: `note`},
	CreateDate:          whereHelpertime_Time{field: `create_date`},
	UpdateDate:          whereHelpertime_Time{field: `update_date`},
	OrderDate:           whereHelpernull_Time{field: `order_date`},
	PaymentDate:         whereHelpernull_Time{field: `payment_date`},
	CurrencyCode:        whereHelpernull_String{field: `currency_code`},
	CompleteMessage:     whereHelpernull_String{field: `complete_message`},
	CompleteMailMessage: whereHelpernull_String{field: `complete_mail_message`},
	AddPoint:            whereHelpertypes_Decimal{field: `add_point`},
	UsePoint:            whereHelpertypes_Decimal{field: `use_point`},
	OrderStatusID:       whereHelpernull_Uint16{field: `order_status_id`},
	DiscriminatorType:   whereHelperstring{field: `discriminator_type`},
}

// DTBOrderRels is where relationship names are stored.
var DTBOrderRels = struct {
	Payment               string
	DeviceType            string
	Sex                   string
	Customer              string
	Job                   string
	Pref                  string
	Country               string
	OrderDTBMailHistories string
	OrderDTBOrderItems    string
	OrderDTBShippings     string
}{
	Payment:               "Payment",
	DeviceType:            "DeviceType",
	Sex:                   "Sex",
	Customer:              "Customer",
	Job:                   "Job",
	Pref:                  "Pref",
	Country:               "Country",
	OrderDTBMailHistories: "OrderDTBMailHistories",
	OrderDTBOrderItems:    "OrderDTBOrderItems",
	OrderDTBShippings:     "OrderDTBShippings",
}

// dtbOrderR is where relationships are stored.
type dtbOrderR struct {
	Payment               *DTBPayment
	DeviceType            *MTBDeviceType
	Sex                   *MTBSex
	Customer              *DTBCustomer
	Job                   *MTBJob
	Pref                  *MTBPref
	Country               *MTBCountry
	OrderDTBMailHistories DTBMailHistorySlice
	OrderDTBOrderItems    DTBOrderItemSlice
	OrderDTBShippings     DTBShippingSlice
}

// NewStruct creates a new relationship struct
func (*dtbOrderR) NewStruct() *dtbOrderR {
	return &dtbOrderR{}
}

// dtbOrderL is where Load methods for each relationship are stored.
type dtbOrderL struct{}

var (
	dtbOrderColumns               = []string{"id", "customer_id", "country_id", "pref_id", "sex_id", "job_id", "payment_id", "device_type_id", "pre_order_id", "order_no", "message", "name01", "name02", "kana01", "kana02", "company_name", "email", "phone_number", "postal_code", "addr01", "addr02", "birth", "subtotal", "discount", "delivery_fee_total", "charge", "tax", "total", "payment_total", "payment_method", "note", "create_date", "update_date", "order_date", "payment_date", "currency_code", "complete_message", "complete_mail_message", "add_point", "use_point", "order_status_id", "discriminator_type"}
	dtbOrderColumnsWithoutDefault = []string{"customer_id", "country_id", "pref_id", "sex_id", "job_id", "payment_id", "device_type_id", "pre_order_id", "order_no", "message", "name01", "name02", "kana01", "kana02", "company_name", "email", "phone_number", "postal_code", "addr01", "addr02", "birth", "payment_method", "note", "create_date", "update_date", "order_date", "payment_date", "currency_code", "complete_message", "complete_mail_message", "order_status_id", "discriminator_type"}
	dtbOrderColumnsWithDefault    = []string{"id", "subtotal", "discount", "delivery_fee_total", "charge", "tax", "total", "payment_total", "add_point", "use_point"}
	dtbOrderPrimaryKeyColumns     = []string{"id"}
)

type (
	// DTBOrderSlice is an alias for a slice of pointers to DTBOrder.
	// This should generally be used opposed to []DTBOrder.
	DTBOrderSlice []*DTBOrder
	// DTBOrderHook is the signature for custom DTBOrder hook methods
	DTBOrderHook func(context.Context, boil.ContextExecutor, *DTBOrder) error

	dtbOrderQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dtbOrderType                 = reflect.TypeOf(&DTBOrder{})
	dtbOrderMapping              = queries.MakeStructMapping(dtbOrderType)
	dtbOrderPrimaryKeyMapping, _ = queries.BindMapping(dtbOrderType, dtbOrderMapping, dtbOrderPrimaryKeyColumns)
	dtbOrderInsertCacheMut       sync.RWMutex
	dtbOrderInsertCache          = make(map[string]insertCache)
	dtbOrderUpdateCacheMut       sync.RWMutex
	dtbOrderUpdateCache          = make(map[string]updateCache)
	dtbOrderUpsertCacheMut       sync.RWMutex
	dtbOrderUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var dtbOrderBeforeInsertHooks []DTBOrderHook
var dtbOrderBeforeUpdateHooks []DTBOrderHook
var dtbOrderBeforeDeleteHooks []DTBOrderHook
var dtbOrderBeforeUpsertHooks []DTBOrderHook

var dtbOrderAfterInsertHooks []DTBOrderHook
var dtbOrderAfterSelectHooks []DTBOrderHook
var dtbOrderAfterUpdateHooks []DTBOrderHook
var dtbOrderAfterDeleteHooks []DTBOrderHook
var dtbOrderAfterUpsertHooks []DTBOrderHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DTBOrder) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbOrderBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DTBOrder) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbOrderBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DTBOrder) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbOrderBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DTBOrder) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbOrderBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DTBOrder) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbOrderAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DTBOrder) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbOrderAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DTBOrder) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbOrderAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DTBOrder) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbOrderAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DTBOrder) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbOrderAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDTBOrderHook registers your hook function for all future operations.
func AddDTBOrderHook(hookPoint boil.HookPoint, dtbOrderHook DTBOrderHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		dtbOrderBeforeInsertHooks = append(dtbOrderBeforeInsertHooks, dtbOrderHook)
	case boil.BeforeUpdateHook:
		dtbOrderBeforeUpdateHooks = append(dtbOrderBeforeUpdateHooks, dtbOrderHook)
	case boil.BeforeDeleteHook:
		dtbOrderBeforeDeleteHooks = append(dtbOrderBeforeDeleteHooks, dtbOrderHook)
	case boil.BeforeUpsertHook:
		dtbOrderBeforeUpsertHooks = append(dtbOrderBeforeUpsertHooks, dtbOrderHook)
	case boil.AfterInsertHook:
		dtbOrderAfterInsertHooks = append(dtbOrderAfterInsertHooks, dtbOrderHook)
	case boil.AfterSelectHook:
		dtbOrderAfterSelectHooks = append(dtbOrderAfterSelectHooks, dtbOrderHook)
	case boil.AfterUpdateHook:
		dtbOrderAfterUpdateHooks = append(dtbOrderAfterUpdateHooks, dtbOrderHook)
	case boil.AfterDeleteHook:
		dtbOrderAfterDeleteHooks = append(dtbOrderAfterDeleteHooks, dtbOrderHook)
	case boil.AfterUpsertHook:
		dtbOrderAfterUpsertHooks = append(dtbOrderAfterUpsertHooks, dtbOrderHook)
	}
}

// One returns a single dtbOrder record from the query.
func (q dtbOrderQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DTBOrder, error) {
	o := &DTBOrder{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for dtb_order")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DTBOrder records from the query.
func (q dtbOrderQuery) All(ctx context.Context, exec boil.ContextExecutor) (DTBOrderSlice, error) {
	var o []*DTBOrder

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to DTBOrder slice")
	}

	if len(dtbOrderAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DTBOrder records in the query.
func (q dtbOrderQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count dtb_order rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dtbOrderQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if dtb_order exists")
	}

	return count > 0, nil
}

// Payment pointed to by the foreign key.
func (o *DTBOrder) Payment(mods ...qm.QueryMod) dtbPaymentQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.PaymentID),
	}

	queryMods = append(queryMods, mods...)

	query := DTBPayments(queryMods...)
	queries.SetFrom(query.Query, "`dtb_payment`")

	return query
}

// DeviceType pointed to by the foreign key.
func (o *DTBOrder) DeviceType(mods ...qm.QueryMod) mtbDeviceTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.DeviceTypeID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBDeviceTypes(queryMods...)
	queries.SetFrom(query.Query, "`mtb_device_type`")

	return query
}

// Sex pointed to by the foreign key.
func (o *DTBOrder) Sex(mods ...qm.QueryMod) mtbSexQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.SexID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBSexes(queryMods...)
	queries.SetFrom(query.Query, "`mtb_sex`")

	return query
}

// Customer pointed to by the foreign key.
func (o *DTBOrder) Customer(mods ...qm.QueryMod) dtbCustomerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.CustomerID),
	}

	queryMods = append(queryMods, mods...)

	query := DTBCustomers(queryMods...)
	queries.SetFrom(query.Query, "`dtb_customer`")

	return query
}

// Job pointed to by the foreign key.
func (o *DTBOrder) Job(mods ...qm.QueryMod) mtbJobQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.JobID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBJobs(queryMods...)
	queries.SetFrom(query.Query, "`mtb_job`")

	return query
}

// Pref pointed to by the foreign key.
func (o *DTBOrder) Pref(mods ...qm.QueryMod) mtbPrefQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.PrefID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBPrefs(queryMods...)
	queries.SetFrom(query.Query, "`mtb_pref`")

	return query
}

// Country pointed to by the foreign key.
func (o *DTBOrder) Country(mods ...qm.QueryMod) mtbCountryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.CountryID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBCountries(queryMods...)
	queries.SetFrom(query.Query, "`mtb_country`")

	return query
}

// OrderDTBMailHistories retrieves all the dtb_mail_history's DTBMailHistories with an executor via order_id column.
func (o *DTBOrder) OrderDTBMailHistories(mods ...qm.QueryMod) dtbMailHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_mail_history`.`order_id`=?", o.ID),
	)

	query := DTBMailHistories(queryMods...)
	queries.SetFrom(query.Query, "`dtb_mail_history`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_mail_history`.*"})
	}

	return query
}

// OrderDTBOrderItems retrieves all the dtb_order_item's DTBOrderItems with an executor via order_id column.
func (o *DTBOrder) OrderDTBOrderItems(mods ...qm.QueryMod) dtbOrderItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_order_item`.`order_id`=?", o.ID),
	)

	query := DTBOrderItems(queryMods...)
	queries.SetFrom(query.Query, "`dtb_order_item`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_order_item`.*"})
	}

	return query
}

// OrderDTBShippings retrieves all the dtb_shipping's DTBShippings with an executor via order_id column.
func (o *DTBOrder) OrderDTBShippings(mods ...qm.QueryMod) dtbShippingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_shipping`.`order_id`=?", o.ID),
	)

	query := DTBShippings(queryMods...)
	queries.SetFrom(query.Query, "`dtb_shipping`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_shipping`.*"})
	}

	return query
}

// LoadPayment allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbOrderL) LoadPayment(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBOrder interface{}, mods queries.Applicator) error {
	var slice []*DTBOrder
	var object *DTBOrder

	if singular {
		object = maybeDTBOrder.(*DTBOrder)
	} else {
		slice = *maybeDTBOrder.(*[]*DTBOrder)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbOrderR{}
		}
		if !queries.IsNil(object.PaymentID) {
			args = append(args, object.PaymentID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbOrderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PaymentID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PaymentID) {
				args = append(args, obj.PaymentID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_payment`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBPayment")
	}

	var resultSlice []*DTBPayment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBPayment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_payment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_payment")
	}

	if len(dtbOrderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Payment = foreign
		if foreign.R == nil {
			foreign.R = &dtbPaymentR{}
		}
		foreign.R.PaymentDTBOrders = append(foreign.R.PaymentDTBOrders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PaymentID, foreign.ID) {
				local.R.Payment = foreign
				if foreign.R == nil {
					foreign.R = &dtbPaymentR{}
				}
				foreign.R.PaymentDTBOrders = append(foreign.R.PaymentDTBOrders, local)
				break
			}
		}
	}

	return nil
}

// LoadDeviceType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbOrderL) LoadDeviceType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBOrder interface{}, mods queries.Applicator) error {
	var slice []*DTBOrder
	var object *DTBOrder

	if singular {
		object = maybeDTBOrder.(*DTBOrder)
	} else {
		slice = *maybeDTBOrder.(*[]*DTBOrder)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbOrderR{}
		}
		if !queries.IsNil(object.DeviceTypeID) {
			args = append(args, object.DeviceTypeID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbOrderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeviceTypeID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeviceTypeID) {
				args = append(args, obj.DeviceTypeID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_device_type`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBDeviceType")
	}

	var resultSlice []*MTBDeviceType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBDeviceType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_device_type")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_device_type")
	}

	if len(dtbOrderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeviceType = foreign
		if foreign.R == nil {
			foreign.R = &mtbDeviceTypeR{}
		}
		foreign.R.DeviceTypeDTBOrders = append(foreign.R.DeviceTypeDTBOrders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeviceTypeID, foreign.ID) {
				local.R.DeviceType = foreign
				if foreign.R == nil {
					foreign.R = &mtbDeviceTypeR{}
				}
				foreign.R.DeviceTypeDTBOrders = append(foreign.R.DeviceTypeDTBOrders, local)
				break
			}
		}
	}

	return nil
}

// LoadSex allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbOrderL) LoadSex(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBOrder interface{}, mods queries.Applicator) error {
	var slice []*DTBOrder
	var object *DTBOrder

	if singular {
		object = maybeDTBOrder.(*DTBOrder)
	} else {
		slice = *maybeDTBOrder.(*[]*DTBOrder)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbOrderR{}
		}
		if !queries.IsNil(object.SexID) {
			args = append(args, object.SexID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbOrderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.SexID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.SexID) {
				args = append(args, obj.SexID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_sex`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBSex")
	}

	var resultSlice []*MTBSex
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBSex")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_sex")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_sex")
	}

	if len(dtbOrderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Sex = foreign
		if foreign.R == nil {
			foreign.R = &mtbSexR{}
		}
		foreign.R.SexDTBOrders = append(foreign.R.SexDTBOrders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SexID, foreign.ID) {
				local.R.Sex = foreign
				if foreign.R == nil {
					foreign.R = &mtbSexR{}
				}
				foreign.R.SexDTBOrders = append(foreign.R.SexDTBOrders, local)
				break
			}
		}
	}

	return nil
}

// LoadCustomer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbOrderL) LoadCustomer(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBOrder interface{}, mods queries.Applicator) error {
	var slice []*DTBOrder
	var object *DTBOrder

	if singular {
		object = maybeDTBOrder.(*DTBOrder)
	} else {
		slice = *maybeDTBOrder.(*[]*DTBOrder)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbOrderR{}
		}
		if !queries.IsNil(object.CustomerID) {
			args = append(args, object.CustomerID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbOrderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CustomerID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CustomerID) {
				args = append(args, obj.CustomerID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_customer`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBCustomer")
	}

	var resultSlice []*DTBCustomer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBCustomer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_customer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_customer")
	}

	if len(dtbOrderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Customer = foreign
		if foreign.R == nil {
			foreign.R = &dtbCustomerR{}
		}
		foreign.R.CustomerDTBOrders = append(foreign.R.CustomerDTBOrders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CustomerID, foreign.ID) {
				local.R.Customer = foreign
				if foreign.R == nil {
					foreign.R = &dtbCustomerR{}
				}
				foreign.R.CustomerDTBOrders = append(foreign.R.CustomerDTBOrders, local)
				break
			}
		}
	}

	return nil
}

// LoadJob allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbOrderL) LoadJob(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBOrder interface{}, mods queries.Applicator) error {
	var slice []*DTBOrder
	var object *DTBOrder

	if singular {
		object = maybeDTBOrder.(*DTBOrder)
	} else {
		slice = *maybeDTBOrder.(*[]*DTBOrder)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbOrderR{}
		}
		if !queries.IsNil(object.JobID) {
			args = append(args, object.JobID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbOrderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.JobID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.JobID) {
				args = append(args, obj.JobID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_job`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBJob")
	}

	var resultSlice []*MTBJob
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBJob")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_job")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_job")
	}

	if len(dtbOrderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Job = foreign
		if foreign.R == nil {
			foreign.R = &mtbJobR{}
		}
		foreign.R.JobDTBOrders = append(foreign.R.JobDTBOrders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.JobID, foreign.ID) {
				local.R.Job = foreign
				if foreign.R == nil {
					foreign.R = &mtbJobR{}
				}
				foreign.R.JobDTBOrders = append(foreign.R.JobDTBOrders, local)
				break
			}
		}
	}

	return nil
}

// LoadPref allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbOrderL) LoadPref(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBOrder interface{}, mods queries.Applicator) error {
	var slice []*DTBOrder
	var object *DTBOrder

	if singular {
		object = maybeDTBOrder.(*DTBOrder)
	} else {
		slice = *maybeDTBOrder.(*[]*DTBOrder)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbOrderR{}
		}
		if !queries.IsNil(object.PrefID) {
			args = append(args, object.PrefID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbOrderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PrefID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PrefID) {
				args = append(args, obj.PrefID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_pref`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBPref")
	}

	var resultSlice []*MTBPref
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBPref")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_pref")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_pref")
	}

	if len(dtbOrderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Pref = foreign
		if foreign.R == nil {
			foreign.R = &mtbPrefR{}
		}
		foreign.R.PrefDTBOrders = append(foreign.R.PrefDTBOrders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PrefID, foreign.ID) {
				local.R.Pref = foreign
				if foreign.R == nil {
					foreign.R = &mtbPrefR{}
				}
				foreign.R.PrefDTBOrders = append(foreign.R.PrefDTBOrders, local)
				break
			}
		}
	}

	return nil
}

// LoadCountry allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbOrderL) LoadCountry(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBOrder interface{}, mods queries.Applicator) error {
	var slice []*DTBOrder
	var object *DTBOrder

	if singular {
		object = maybeDTBOrder.(*DTBOrder)
	} else {
		slice = *maybeDTBOrder.(*[]*DTBOrder)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbOrderR{}
		}
		if !queries.IsNil(object.CountryID) {
			args = append(args, object.CountryID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbOrderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CountryID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CountryID) {
				args = append(args, obj.CountryID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_country`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBCountry")
	}

	var resultSlice []*MTBCountry
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBCountry")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_country")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_country")
	}

	if len(dtbOrderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Country = foreign
		if foreign.R == nil {
			foreign.R = &mtbCountryR{}
		}
		foreign.R.CountryDTBOrders = append(foreign.R.CountryDTBOrders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CountryID, foreign.ID) {
				local.R.Country = foreign
				if foreign.R == nil {
					foreign.R = &mtbCountryR{}
				}
				foreign.R.CountryDTBOrders = append(foreign.R.CountryDTBOrders, local)
				break
			}
		}
	}

	return nil
}

// LoadOrderDTBMailHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbOrderL) LoadOrderDTBMailHistories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBOrder interface{}, mods queries.Applicator) error {
	var slice []*DTBOrder
	var object *DTBOrder

	if singular {
		object = maybeDTBOrder.(*DTBOrder)
	} else {
		slice = *maybeDTBOrder.(*[]*DTBOrder)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbOrderR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbOrderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_mail_history`), qm.WhereIn(`order_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_mail_history")
	}

	var resultSlice []*DTBMailHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_mail_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_mail_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_mail_history")
	}

	if len(dtbMailHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OrderDTBMailHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbMailHistoryR{}
			}
			foreign.R.Order = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.OrderID) {
				local.R.OrderDTBMailHistories = append(local.R.OrderDTBMailHistories, foreign)
				if foreign.R == nil {
					foreign.R = &dtbMailHistoryR{}
				}
				foreign.R.Order = local
				break
			}
		}
	}

	return nil
}

// LoadOrderDTBOrderItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbOrderL) LoadOrderDTBOrderItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBOrder interface{}, mods queries.Applicator) error {
	var slice []*DTBOrder
	var object *DTBOrder

	if singular {
		object = maybeDTBOrder.(*DTBOrder)
	} else {
		slice = *maybeDTBOrder.(*[]*DTBOrder)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbOrderR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbOrderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_order_item`), qm.WhereIn(`order_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_order_item")
	}

	var resultSlice []*DTBOrderItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_order_item")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_order_item")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_order_item")
	}

	if len(dtbOrderItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OrderDTBOrderItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbOrderItemR{}
			}
			foreign.R.Order = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.OrderID) {
				local.R.OrderDTBOrderItems = append(local.R.OrderDTBOrderItems, foreign)
				if foreign.R == nil {
					foreign.R = &dtbOrderItemR{}
				}
				foreign.R.Order = local
				break
			}
		}
	}

	return nil
}

// LoadOrderDTBShippings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbOrderL) LoadOrderDTBShippings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBOrder interface{}, mods queries.Applicator) error {
	var slice []*DTBOrder
	var object *DTBOrder

	if singular {
		object = maybeDTBOrder.(*DTBOrder)
	} else {
		slice = *maybeDTBOrder.(*[]*DTBOrder)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbOrderR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbOrderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_shipping`), qm.WhereIn(`order_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_shipping")
	}

	var resultSlice []*DTBShipping
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_shipping")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_shipping")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_shipping")
	}

	if len(dtbShippingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OrderDTBShippings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbShippingR{}
			}
			foreign.R.Order = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.OrderID) {
				local.R.OrderDTBShippings = append(local.R.OrderDTBShippings, foreign)
				if foreign.R == nil {
					foreign.R = &dtbShippingR{}
				}
				foreign.R.Order = local
				break
			}
		}
	}

	return nil
}

// SetPayment of the dtbOrder to the related item.
// Sets o.R.Payment to related.
// Adds o to related.R.PaymentDTBOrders.
func (o *DTBOrder) SetPayment(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBPayment) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_order` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"payment_id"}),
		strmangle.WhereClause("`", "`", 0, dtbOrderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PaymentID, related.ID)
	if o.R == nil {
		o.R = &dtbOrderR{
			Payment: related,
		}
	} else {
		o.R.Payment = related
	}

	if related.R == nil {
		related.R = &dtbPaymentR{
			PaymentDTBOrders: DTBOrderSlice{o},
		}
	} else {
		related.R.PaymentDTBOrders = append(related.R.PaymentDTBOrders, o)
	}

	return nil
}

// RemovePayment relationship.
// Sets o.R.Payment to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBOrder) RemovePayment(ctx context.Context, exec boil.ContextExecutor, related *DTBPayment) error {
	var err error

	queries.SetScanner(&o.PaymentID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("payment_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Payment = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PaymentDTBOrders {
		if queries.Equal(o.PaymentID, ri.PaymentID) {
			continue
		}

		ln := len(related.R.PaymentDTBOrders)
		if ln > 1 && i < ln-1 {
			related.R.PaymentDTBOrders[i] = related.R.PaymentDTBOrders[ln-1]
		}
		related.R.PaymentDTBOrders = related.R.PaymentDTBOrders[:ln-1]
		break
	}
	return nil
}

// SetDeviceType of the dtbOrder to the related item.
// Sets o.R.DeviceType to related.
// Adds o to related.R.DeviceTypeDTBOrders.
func (o *DTBOrder) SetDeviceType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBDeviceType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_order` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"device_type_id"}),
		strmangle.WhereClause("`", "`", 0, dtbOrderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeviceTypeID, related.ID)
	if o.R == nil {
		o.R = &dtbOrderR{
			DeviceType: related,
		}
	} else {
		o.R.DeviceType = related
	}

	if related.R == nil {
		related.R = &mtbDeviceTypeR{
			DeviceTypeDTBOrders: DTBOrderSlice{o},
		}
	} else {
		related.R.DeviceTypeDTBOrders = append(related.R.DeviceTypeDTBOrders, o)
	}

	return nil
}

// RemoveDeviceType relationship.
// Sets o.R.DeviceType to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBOrder) RemoveDeviceType(ctx context.Context, exec boil.ContextExecutor, related *MTBDeviceType) error {
	var err error

	queries.SetScanner(&o.DeviceTypeID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("device_type_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.DeviceType = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DeviceTypeDTBOrders {
		if queries.Equal(o.DeviceTypeID, ri.DeviceTypeID) {
			continue
		}

		ln := len(related.R.DeviceTypeDTBOrders)
		if ln > 1 && i < ln-1 {
			related.R.DeviceTypeDTBOrders[i] = related.R.DeviceTypeDTBOrders[ln-1]
		}
		related.R.DeviceTypeDTBOrders = related.R.DeviceTypeDTBOrders[:ln-1]
		break
	}
	return nil
}

// SetSex of the dtbOrder to the related item.
// Sets o.R.Sex to related.
// Adds o to related.R.SexDTBOrders.
func (o *DTBOrder) SetSex(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBSex) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_order` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"sex_id"}),
		strmangle.WhereClause("`", "`", 0, dtbOrderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SexID, related.ID)
	if o.R == nil {
		o.R = &dtbOrderR{
			Sex: related,
		}
	} else {
		o.R.Sex = related
	}

	if related.R == nil {
		related.R = &mtbSexR{
			SexDTBOrders: DTBOrderSlice{o},
		}
	} else {
		related.R.SexDTBOrders = append(related.R.SexDTBOrders, o)
	}

	return nil
}

// RemoveSex relationship.
// Sets o.R.Sex to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBOrder) RemoveSex(ctx context.Context, exec boil.ContextExecutor, related *MTBSex) error {
	var err error

	queries.SetScanner(&o.SexID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("sex_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Sex = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.SexDTBOrders {
		if queries.Equal(o.SexID, ri.SexID) {
			continue
		}

		ln := len(related.R.SexDTBOrders)
		if ln > 1 && i < ln-1 {
			related.R.SexDTBOrders[i] = related.R.SexDTBOrders[ln-1]
		}
		related.R.SexDTBOrders = related.R.SexDTBOrders[:ln-1]
		break
	}
	return nil
}

// SetCustomer of the dtbOrder to the related item.
// Sets o.R.Customer to related.
// Adds o to related.R.CustomerDTBOrders.
func (o *DTBOrder) SetCustomer(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBCustomer) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_order` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"customer_id"}),
		strmangle.WhereClause("`", "`", 0, dtbOrderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CustomerID, related.ID)
	if o.R == nil {
		o.R = &dtbOrderR{
			Customer: related,
		}
	} else {
		o.R.Customer = related
	}

	if related.R == nil {
		related.R = &dtbCustomerR{
			CustomerDTBOrders: DTBOrderSlice{o},
		}
	} else {
		related.R.CustomerDTBOrders = append(related.R.CustomerDTBOrders, o)
	}

	return nil
}

// RemoveCustomer relationship.
// Sets o.R.Customer to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBOrder) RemoveCustomer(ctx context.Context, exec boil.ContextExecutor, related *DTBCustomer) error {
	var err error

	queries.SetScanner(&o.CustomerID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("customer_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Customer = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CustomerDTBOrders {
		if queries.Equal(o.CustomerID, ri.CustomerID) {
			continue
		}

		ln := len(related.R.CustomerDTBOrders)
		if ln > 1 && i < ln-1 {
			related.R.CustomerDTBOrders[i] = related.R.CustomerDTBOrders[ln-1]
		}
		related.R.CustomerDTBOrders = related.R.CustomerDTBOrders[:ln-1]
		break
	}
	return nil
}

// SetJob of the dtbOrder to the related item.
// Sets o.R.Job to related.
// Adds o to related.R.JobDTBOrders.
func (o *DTBOrder) SetJob(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBJob) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_order` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"job_id"}),
		strmangle.WhereClause("`", "`", 0, dtbOrderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.JobID, related.ID)
	if o.R == nil {
		o.R = &dtbOrderR{
			Job: related,
		}
	} else {
		o.R.Job = related
	}

	if related.R == nil {
		related.R = &mtbJobR{
			JobDTBOrders: DTBOrderSlice{o},
		}
	} else {
		related.R.JobDTBOrders = append(related.R.JobDTBOrders, o)
	}

	return nil
}

// RemoveJob relationship.
// Sets o.R.Job to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBOrder) RemoveJob(ctx context.Context, exec boil.ContextExecutor, related *MTBJob) error {
	var err error

	queries.SetScanner(&o.JobID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("job_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Job = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.JobDTBOrders {
		if queries.Equal(o.JobID, ri.JobID) {
			continue
		}

		ln := len(related.R.JobDTBOrders)
		if ln > 1 && i < ln-1 {
			related.R.JobDTBOrders[i] = related.R.JobDTBOrders[ln-1]
		}
		related.R.JobDTBOrders = related.R.JobDTBOrders[:ln-1]
		break
	}
	return nil
}

// SetPref of the dtbOrder to the related item.
// Sets o.R.Pref to related.
// Adds o to related.R.PrefDTBOrders.
func (o *DTBOrder) SetPref(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBPref) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_order` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"pref_id"}),
		strmangle.WhereClause("`", "`", 0, dtbOrderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PrefID, related.ID)
	if o.R == nil {
		o.R = &dtbOrderR{
			Pref: related,
		}
	} else {
		o.R.Pref = related
	}

	if related.R == nil {
		related.R = &mtbPrefR{
			PrefDTBOrders: DTBOrderSlice{o},
		}
	} else {
		related.R.PrefDTBOrders = append(related.R.PrefDTBOrders, o)
	}

	return nil
}

// RemovePref relationship.
// Sets o.R.Pref to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBOrder) RemovePref(ctx context.Context, exec boil.ContextExecutor, related *MTBPref) error {
	var err error

	queries.SetScanner(&o.PrefID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("pref_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Pref = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PrefDTBOrders {
		if queries.Equal(o.PrefID, ri.PrefID) {
			continue
		}

		ln := len(related.R.PrefDTBOrders)
		if ln > 1 && i < ln-1 {
			related.R.PrefDTBOrders[i] = related.R.PrefDTBOrders[ln-1]
		}
		related.R.PrefDTBOrders = related.R.PrefDTBOrders[:ln-1]
		break
	}
	return nil
}

// SetCountry of the dtbOrder to the related item.
// Sets o.R.Country to related.
// Adds o to related.R.CountryDTBOrders.
func (o *DTBOrder) SetCountry(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBCountry) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_order` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"country_id"}),
		strmangle.WhereClause("`", "`", 0, dtbOrderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CountryID, related.ID)
	if o.R == nil {
		o.R = &dtbOrderR{
			Country: related,
		}
	} else {
		o.R.Country = related
	}

	if related.R == nil {
		related.R = &mtbCountryR{
			CountryDTBOrders: DTBOrderSlice{o},
		}
	} else {
		related.R.CountryDTBOrders = append(related.R.CountryDTBOrders, o)
	}

	return nil
}

// RemoveCountry relationship.
// Sets o.R.Country to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBOrder) RemoveCountry(ctx context.Context, exec boil.ContextExecutor, related *MTBCountry) error {
	var err error

	queries.SetScanner(&o.CountryID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("country_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Country = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CountryDTBOrders {
		if queries.Equal(o.CountryID, ri.CountryID) {
			continue
		}

		ln := len(related.R.CountryDTBOrders)
		if ln > 1 && i < ln-1 {
			related.R.CountryDTBOrders[i] = related.R.CountryDTBOrders[ln-1]
		}
		related.R.CountryDTBOrders = related.R.CountryDTBOrders[:ln-1]
		break
	}
	return nil
}

// AddOrderDTBMailHistories adds the given related objects to the existing relationships
// of the dtb_order, optionally inserting them as new records.
// Appends related to o.R.OrderDTBMailHistories.
// Sets related.R.Order appropriately.
func (o *DTBOrder) AddOrderDTBMailHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBMailHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_mail_history` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"order_id"}),
				strmangle.WhereClause("`", "`", 0, dtbMailHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbOrderR{
			OrderDTBMailHistories: related,
		}
	} else {
		o.R.OrderDTBMailHistories = append(o.R.OrderDTBMailHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbMailHistoryR{
				Order: o,
			}
		} else {
			rel.R.Order = o
		}
	}
	return nil
}

// SetOrderDTBMailHistories removes all previously related items of the
// dtb_order replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Order's OrderDTBMailHistories accordingly.
// Replaces o.R.OrderDTBMailHistories with related.
// Sets related.R.Order's OrderDTBMailHistories accordingly.
func (o *DTBOrder) SetOrderDTBMailHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBMailHistory) error {
	query := "update `dtb_mail_history` set `order_id` = null where `order_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.OrderDTBMailHistories {
			queries.SetScanner(&rel.OrderID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Order = nil
		}

		o.R.OrderDTBMailHistories = nil
	}
	return o.AddOrderDTBMailHistories(ctx, exec, insert, related...)
}

// RemoveOrderDTBMailHistories relationships from objects passed in.
// Removes related items from R.OrderDTBMailHistories (uses pointer comparison, removal does not keep order)
// Sets related.R.Order.
func (o *DTBOrder) RemoveOrderDTBMailHistories(ctx context.Context, exec boil.ContextExecutor, related ...*DTBMailHistory) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderID, nil)
		if rel.R != nil {
			rel.R.Order = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("order_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderDTBMailHistories {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderDTBMailHistories)
			if ln > 1 && i < ln-1 {
				o.R.OrderDTBMailHistories[i] = o.R.OrderDTBMailHistories[ln-1]
			}
			o.R.OrderDTBMailHistories = o.R.OrderDTBMailHistories[:ln-1]
			break
		}
	}

	return nil
}

// AddOrderDTBOrderItems adds the given related objects to the existing relationships
// of the dtb_order, optionally inserting them as new records.
// Appends related to o.R.OrderDTBOrderItems.
// Sets related.R.Order appropriately.
func (o *DTBOrder) AddOrderDTBOrderItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBOrderItem) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_order_item` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"order_id"}),
				strmangle.WhereClause("`", "`", 0, dtbOrderItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbOrderR{
			OrderDTBOrderItems: related,
		}
	} else {
		o.R.OrderDTBOrderItems = append(o.R.OrderDTBOrderItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbOrderItemR{
				Order: o,
			}
		} else {
			rel.R.Order = o
		}
	}
	return nil
}

// SetOrderDTBOrderItems removes all previously related items of the
// dtb_order replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Order's OrderDTBOrderItems accordingly.
// Replaces o.R.OrderDTBOrderItems with related.
// Sets related.R.Order's OrderDTBOrderItems accordingly.
func (o *DTBOrder) SetOrderDTBOrderItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBOrderItem) error {
	query := "update `dtb_order_item` set `order_id` = null where `order_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.OrderDTBOrderItems {
			queries.SetScanner(&rel.OrderID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Order = nil
		}

		o.R.OrderDTBOrderItems = nil
	}
	return o.AddOrderDTBOrderItems(ctx, exec, insert, related...)
}

// RemoveOrderDTBOrderItems relationships from objects passed in.
// Removes related items from R.OrderDTBOrderItems (uses pointer comparison, removal does not keep order)
// Sets related.R.Order.
func (o *DTBOrder) RemoveOrderDTBOrderItems(ctx context.Context, exec boil.ContextExecutor, related ...*DTBOrderItem) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderID, nil)
		if rel.R != nil {
			rel.R.Order = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("order_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderDTBOrderItems {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderDTBOrderItems)
			if ln > 1 && i < ln-1 {
				o.R.OrderDTBOrderItems[i] = o.R.OrderDTBOrderItems[ln-1]
			}
			o.R.OrderDTBOrderItems = o.R.OrderDTBOrderItems[:ln-1]
			break
		}
	}

	return nil
}

// AddOrderDTBShippings adds the given related objects to the existing relationships
// of the dtb_order, optionally inserting them as new records.
// Appends related to o.R.OrderDTBShippings.
// Sets related.R.Order appropriately.
func (o *DTBOrder) AddOrderDTBShippings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBShipping) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_shipping` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"order_id"}),
				strmangle.WhereClause("`", "`", 0, dtbShippingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbOrderR{
			OrderDTBShippings: related,
		}
	} else {
		o.R.OrderDTBShippings = append(o.R.OrderDTBShippings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbShippingR{
				Order: o,
			}
		} else {
			rel.R.Order = o
		}
	}
	return nil
}

// SetOrderDTBShippings removes all previously related items of the
// dtb_order replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Order's OrderDTBShippings accordingly.
// Replaces o.R.OrderDTBShippings with related.
// Sets related.R.Order's OrderDTBShippings accordingly.
func (o *DTBOrder) SetOrderDTBShippings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBShipping) error {
	query := "update `dtb_shipping` set `order_id` = null where `order_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.OrderDTBShippings {
			queries.SetScanner(&rel.OrderID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Order = nil
		}

		o.R.OrderDTBShippings = nil
	}
	return o.AddOrderDTBShippings(ctx, exec, insert, related...)
}

// RemoveOrderDTBShippings relationships from objects passed in.
// Removes related items from R.OrderDTBShippings (uses pointer comparison, removal does not keep order)
// Sets related.R.Order.
func (o *DTBOrder) RemoveOrderDTBShippings(ctx context.Context, exec boil.ContextExecutor, related ...*DTBShipping) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderID, nil)
		if rel.R != nil {
			rel.R.Order = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("order_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderDTBShippings {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderDTBShippings)
			if ln > 1 && i < ln-1 {
				o.R.OrderDTBShippings[i] = o.R.OrderDTBShippings[ln-1]
			}
			o.R.OrderDTBShippings = o.R.OrderDTBShippings[:ln-1]
			break
		}
	}

	return nil
}

// DTBOrders retrieves all the records using an executor.
func DTBOrders(mods ...qm.QueryMod) dtbOrderQuery {
	mods = append(mods, qm.From("`dtb_order`"))
	return dtbOrderQuery{NewQuery(mods...)}
}

// FindDTBOrder retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDTBOrder(ctx context.Context, exec boil.ContextExecutor, iD uint, selectCols ...string) (*DTBOrder, error) {
	dtbOrderObj := &DTBOrder{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `dtb_order` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, dtbOrderObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from dtb_order")
	}

	return dtbOrderObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DTBOrder) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_order provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbOrderColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dtbOrderInsertCacheMut.RLock()
	cache, cached := dtbOrderInsertCache[key]
	dtbOrderInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dtbOrderColumns,
			dtbOrderColumnsWithDefault,
			dtbOrderColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dtbOrderType, dtbOrderMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dtbOrderType, dtbOrderMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `dtb_order` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `dtb_order` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `dtb_order` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dtbOrderPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into dtb_order")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbOrderMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_order")
	}

CacheNoHooks:
	if !cached {
		dtbOrderInsertCacheMut.Lock()
		dtbOrderInsertCache[key] = cache
		dtbOrderInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DTBOrder.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DTBOrder) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	dtbOrderUpdateCacheMut.RLock()
	cache, cached := dtbOrderUpdateCache[key]
	dtbOrderUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dtbOrderColumns,
			dtbOrderPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("model: unable to update dtb_order, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `dtb_order` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dtbOrderPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dtbOrderType, dtbOrderMapping, append(wl, dtbOrderPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update dtb_order row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by update for dtb_order")
	}

	if !cached {
		dtbOrderUpdateCacheMut.Lock()
		dtbOrderUpdateCache[key] = cache
		dtbOrderUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q dtbOrderQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all for dtb_order")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected for dtb_order")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DTBOrderSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbOrderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `dtb_order` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbOrderPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all in dtbOrder slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected all in update all dtbOrder")
	}
	return rowsAff, nil
}

var mySQLDTBOrderUniqueColumns = []string{
	"id",
	"pre_order_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DTBOrder) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_order provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbOrderColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDTBOrderUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dtbOrderUpsertCacheMut.RLock()
	cache, cached := dtbOrderUpsertCache[key]
	dtbOrderUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dtbOrderColumns,
			dtbOrderColumnsWithDefault,
			dtbOrderColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			dtbOrderColumns,
			dtbOrderPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("model: unable to upsert dtb_order, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "dtb_order", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `dtb_order` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dtbOrderType, dtbOrderMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dtbOrderType, dtbOrderMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to upsert for dtb_order")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbOrderMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dtbOrderType, dtbOrderMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "model: unable to retrieve unique values for dtb_order")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_order")
	}

CacheNoHooks:
	if !cached {
		dtbOrderUpsertCacheMut.Lock()
		dtbOrderUpsertCache[key] = cache
		dtbOrderUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DTBOrder record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DTBOrder) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBOrder provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dtbOrderPrimaryKeyMapping)
	sql := "DELETE FROM `dtb_order` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete from dtb_order")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by delete for dtb_order")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q dtbOrderQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("model: no dtbOrderQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtb_order")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_order")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DTBOrderSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBOrder slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(dtbOrderBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbOrderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `dtb_order` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbOrderPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtbOrder slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_order")
	}

	if len(dtbOrderAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DTBOrder) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDTBOrder(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DTBOrderSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DTBOrderSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbOrderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `dtb_order`.* FROM `dtb_order` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbOrderPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in DTBOrderSlice")
	}

	*o = slice

	return nil
}

// DTBOrderExists checks if the DTBOrder row exists.
func DTBOrderExists(ctx context.Context, exec boil.ContextExecutor, iD uint) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `dtb_order` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if dtb_order exists")
	}

	return exists, nil
}
