// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// DTBProductClass is an object representing the database table.
type DTBProductClass struct {
	ID                 uint              `boil:"id" json:"id" toml:"id" yaml:"id"`
	ProductID          null.Uint         `boil:"product_id" json:"product_id,omitempty" toml:"product_id" yaml:"product_id,omitempty"`
	SaleTypeID         null.Uint16       `boil:"sale_type_id" json:"sale_type_id,omitempty" toml:"sale_type_id" yaml:"sale_type_id,omitempty"`
	ClassCategoryID1   null.Uint         `boil:"class_category_id1" json:"class_category_id1,omitempty" toml:"class_category_id1" yaml:"class_category_id1,omitempty"`
	ClassCategoryID2   null.Uint         `boil:"class_category_id2" json:"class_category_id2,omitempty" toml:"class_category_id2" yaml:"class_category_id2,omitempty"`
	DeliveryDurationID null.Uint         `boil:"delivery_duration_id" json:"delivery_duration_id,omitempty" toml:"delivery_duration_id" yaml:"delivery_duration_id,omitempty"`
	CreatorID          null.Uint         `boil:"creator_id" json:"creator_id,omitempty" toml:"creator_id" yaml:"creator_id,omitempty"`
	ProductCode        null.String       `boil:"product_code" json:"product_code,omitempty" toml:"product_code" yaml:"product_code,omitempty"`
	Stock              types.NullDecimal `boil:"stock" json:"stock,omitempty" toml:"stock" yaml:"stock,omitempty"`
	StockUnlimited     bool              `boil:"stock_unlimited" json:"stock_unlimited" toml:"stock_unlimited" yaml:"stock_unlimited"`
	SaleLimit          types.NullDecimal `boil:"sale_limit" json:"sale_limit,omitempty" toml:"sale_limit" yaml:"sale_limit,omitempty"`
	Price01            types.NullDecimal `boil:"price01" json:"price01,omitempty" toml:"price01" yaml:"price01,omitempty"`
	Price02            types.Decimal     `boil:"price02" json:"price02" toml:"price02" yaml:"price02"`
	DeliveryFee        types.NullDecimal `boil:"delivery_fee" json:"delivery_fee,omitempty" toml:"delivery_fee" yaml:"delivery_fee,omitempty"`
	Visible            bool              `boil:"visible" json:"visible" toml:"visible" yaml:"visible"`
	CreateDate         time.Time         `boil:"create_date" json:"create_date" toml:"create_date" yaml:"create_date"`
	UpdateDate         time.Time         `boil:"update_date" json:"update_date" toml:"update_date" yaml:"update_date"`
	CurrencyCode       null.String       `boil:"currency_code" json:"currency_code,omitempty" toml:"currency_code" yaml:"currency_code,omitempty"`
	PointRate          types.NullDecimal `boil:"point_rate" json:"point_rate,omitempty" toml:"point_rate" yaml:"point_rate,omitempty"`
	DiscriminatorType  string            `boil:"discriminator_type" json:"discriminator_type" toml:"discriminator_type" yaml:"discriminator_type"`

	R *dtbProductClassR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dtbProductClassL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DTBProductClassColumns = struct {
	ID                 string
	ProductID          string
	SaleTypeID         string
	ClassCategoryID1   string
	ClassCategoryID2   string
	DeliveryDurationID string
	CreatorID          string
	ProductCode        string
	Stock              string
	StockUnlimited     string
	SaleLimit          string
	Price01            string
	Price02            string
	DeliveryFee        string
	Visible            string
	CreateDate         string
	UpdateDate         string
	CurrencyCode       string
	PointRate          string
	DiscriminatorType  string
}{
	ID:                 "id",
	ProductID:          "product_id",
	SaleTypeID:         "sale_type_id",
	ClassCategoryID1:   "class_category_id1",
	ClassCategoryID2:   "class_category_id2",
	DeliveryDurationID: "delivery_duration_id",
	CreatorID:          "creator_id",
	ProductCode:        "product_code",
	Stock:              "stock",
	StockUnlimited:     "stock_unlimited",
	SaleLimit:          "sale_limit",
	Price01:            "price01",
	Price02:            "price02",
	DeliveryFee:        "delivery_fee",
	Visible:            "visible",
	CreateDate:         "create_date",
	UpdateDate:         "update_date",
	CurrencyCode:       "currency_code",
	PointRate:          "point_rate",
	DiscriminatorType:  "discriminator_type",
}

// Generated where

type whereHelpertypes_NullDecimal struct{ field string }

func (w whereHelpertypes_NullDecimal) EQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_NullDecimal) NEQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_NullDecimal) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_NullDecimal) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpertypes_NullDecimal) LT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_NullDecimal) LTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_NullDecimal) GT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_NullDecimal) GTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpertypes_Decimal struct{ field string }

func (w whereHelpertypes_Decimal) EQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_Decimal) NEQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_Decimal) LT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Decimal) LTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Decimal) GT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Decimal) GTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var DTBProductClassWhere = struct {
	ID                 whereHelperuint
	ProductID          whereHelpernull_Uint
	SaleTypeID         whereHelpernull_Uint16
	ClassCategoryID1   whereHelpernull_Uint
	ClassCategoryID2   whereHelpernull_Uint
	DeliveryDurationID whereHelpernull_Uint
	CreatorID          whereHelpernull_Uint
	ProductCode        whereHelpernull_String
	Stock              whereHelpertypes_NullDecimal
	StockUnlimited     whereHelperbool
	SaleLimit          whereHelpertypes_NullDecimal
	Price01            whereHelpertypes_NullDecimal
	Price02            whereHelpertypes_Decimal
	DeliveryFee        whereHelpertypes_NullDecimal
	Visible            whereHelperbool
	CreateDate         whereHelpertime_Time
	UpdateDate         whereHelpertime_Time
	CurrencyCode       whereHelpernull_String
	PointRate          whereHelpertypes_NullDecimal
	DiscriminatorType  whereHelperstring
}{
	ID:                 whereHelperuint{field: `id`},
	ProductID:          whereHelpernull_Uint{field: `product_id`},
	SaleTypeID:         whereHelpernull_Uint16{field: `sale_type_id`},
	ClassCategoryID1:   whereHelpernull_Uint{field: `class_category_id1`},
	ClassCategoryID2:   whereHelpernull_Uint{field: `class_category_id2`},
	DeliveryDurationID: whereHelpernull_Uint{field: `delivery_duration_id`},
	CreatorID:          whereHelpernull_Uint{field: `creator_id`},
	ProductCode:        whereHelpernull_String{field: `product_code`},
	Stock:              whereHelpertypes_NullDecimal{field: `stock`},
	StockUnlimited:     whereHelperbool{field: `stock_unlimited`},
	SaleLimit:          whereHelpertypes_NullDecimal{field: `sale_limit`},
	Price01:            whereHelpertypes_NullDecimal{field: `price01`},
	Price02:            whereHelpertypes_Decimal{field: `price02`},
	DeliveryFee:        whereHelpertypes_NullDecimal{field: `delivery_fee`},
	Visible:            whereHelperbool{field: `visible`},
	CreateDate:         whereHelpertime_Time{field: `create_date`},
	UpdateDate:         whereHelpertime_Time{field: `update_date`},
	CurrencyCode:       whereHelpernull_String{field: `currency_code`},
	PointRate:          whereHelpertypes_NullDecimal{field: `point_rate`},
	DiscriminatorType:  whereHelperstring{field: `discriminator_type`},
}

// DTBProductClassRels is where relationship names are stored.
var DTBProductClassRels = struct {
	Product                      string
	ProductClassDTBProductStocks string
}{
	Product:                      "Product",
	ProductClassDTBProductStocks: "ProductClassDTBProductStocks",
}

// dtbProductClassR is where relationships are stored.
type dtbProductClassR struct {
	Product                      *DTBProduct
	ProductClassDTBProductStocks DTBProductStockSlice
}

// NewStruct creates a new relationship struct
func (*dtbProductClassR) NewStruct() *dtbProductClassR {
	return &dtbProductClassR{}
}

// dtbProductClassL is where Load methods for each relationship are stored.
type dtbProductClassL struct{}

var (
	dtbProductClassColumns               = []string{"id", "product_id", "sale_type_id", "class_category_id1", "class_category_id2", "delivery_duration_id", "creator_id", "product_code", "stock", "stock_unlimited", "sale_limit", "price01", "price02", "delivery_fee", "visible", "create_date", "update_date", "currency_code", "point_rate", "discriminator_type"}
	dtbProductClassColumnsWithoutDefault = []string{"product_id", "sale_type_id", "class_category_id1", "class_category_id2", "delivery_duration_id", "creator_id", "product_code", "stock", "sale_limit", "price01", "price02", "delivery_fee", "create_date", "update_date", "currency_code", "point_rate", "discriminator_type"}
	dtbProductClassColumnsWithDefault    = []string{"id", "stock_unlimited", "visible"}
	dtbProductClassPrimaryKeyColumns     = []string{"id"}
)

type (
	// DTBProductClassSlice is an alias for a slice of pointers to DTBProductClass.
	// This should generally be used opposed to []DTBProductClass.
	DTBProductClassSlice []*DTBProductClass
	// DTBProductClassHook is the signature for custom DTBProductClass hook methods
	DTBProductClassHook func(context.Context, boil.ContextExecutor, *DTBProductClass) error

	dtbProductClassQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dtbProductClassType                 = reflect.TypeOf(&DTBProductClass{})
	dtbProductClassMapping              = queries.MakeStructMapping(dtbProductClassType)
	dtbProductClassPrimaryKeyMapping, _ = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, dtbProductClassPrimaryKeyColumns)
	dtbProductClassInsertCacheMut       sync.RWMutex
	dtbProductClassInsertCache          = make(map[string]insertCache)
	dtbProductClassUpdateCacheMut       sync.RWMutex
	dtbProductClassUpdateCache          = make(map[string]updateCache)
	dtbProductClassUpsertCacheMut       sync.RWMutex
	dtbProductClassUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var dtbProductClassBeforeInsertHooks []DTBProductClassHook
var dtbProductClassBeforeUpdateHooks []DTBProductClassHook
var dtbProductClassBeforeDeleteHooks []DTBProductClassHook
var dtbProductClassBeforeUpsertHooks []DTBProductClassHook

var dtbProductClassAfterInsertHooks []DTBProductClassHook
var dtbProductClassAfterSelectHooks []DTBProductClassHook
var dtbProductClassAfterUpdateHooks []DTBProductClassHook
var dtbProductClassAfterDeleteHooks []DTBProductClassHook
var dtbProductClassAfterUpsertHooks []DTBProductClassHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DTBProductClass) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DTBProductClass) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DTBProductClass) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DTBProductClass) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DTBProductClass) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DTBProductClass) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DTBProductClass) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DTBProductClass) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DTBProductClass) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDTBProductClassHook registers your hook function for all future operations.
func AddDTBProductClassHook(hookPoint boil.HookPoint, dtbProductClassHook DTBProductClassHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		dtbProductClassBeforeInsertHooks = append(dtbProductClassBeforeInsertHooks, dtbProductClassHook)
	case boil.BeforeUpdateHook:
		dtbProductClassBeforeUpdateHooks = append(dtbProductClassBeforeUpdateHooks, dtbProductClassHook)
	case boil.BeforeDeleteHook:
		dtbProductClassBeforeDeleteHooks = append(dtbProductClassBeforeDeleteHooks, dtbProductClassHook)
	case boil.BeforeUpsertHook:
		dtbProductClassBeforeUpsertHooks = append(dtbProductClassBeforeUpsertHooks, dtbProductClassHook)
	case boil.AfterInsertHook:
		dtbProductClassAfterInsertHooks = append(dtbProductClassAfterInsertHooks, dtbProductClassHook)
	case boil.AfterSelectHook:
		dtbProductClassAfterSelectHooks = append(dtbProductClassAfterSelectHooks, dtbProductClassHook)
	case boil.AfterUpdateHook:
		dtbProductClassAfterUpdateHooks = append(dtbProductClassAfterUpdateHooks, dtbProductClassHook)
	case boil.AfterDeleteHook:
		dtbProductClassAfterDeleteHooks = append(dtbProductClassAfterDeleteHooks, dtbProductClassHook)
	case boil.AfterUpsertHook:
		dtbProductClassAfterUpsertHooks = append(dtbProductClassAfterUpsertHooks, dtbProductClassHook)
	}
}

// One returns a single dtbProductClass record from the query.
func (q dtbProductClassQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DTBProductClass, error) {
	o := &DTBProductClass{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for dtb_product_class")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DTBProductClass records from the query.
func (q dtbProductClassQuery) All(ctx context.Context, exec boil.ContextExecutor) (DTBProductClassSlice, error) {
	var o []*DTBProductClass

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to DTBProductClass slice")
	}

	if len(dtbProductClassAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DTBProductClass records in the query.
func (q dtbProductClassQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count dtb_product_class rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dtbProductClassQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if dtb_product_class exists")
	}

	return count > 0, nil
}

// Product pointed to by the foreign key.
func (o *DTBProductClass) Product(mods ...qm.QueryMod) dtbProductQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.ProductID),
	}

	queryMods = append(queryMods, mods...)

	query := DTBProducts(queryMods...)
	queries.SetFrom(query.Query, "`dtb_product`")

	return query
}

// ProductClassDTBProductStocks retrieves all the dtb_product_stock's DTBProductStocks with an executor via product_class_id column.
func (o *DTBProductClass) ProductClassDTBProductStocks(mods ...qm.QueryMod) dtbProductStockQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_product_stock`.`product_class_id`=?", o.ID),
	)

	query := DTBProductStocks(queryMods...)
	queries.SetFrom(query.Query, "`dtb_product_stock`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_product_stock`.*"})
	}

	return query
}

// LoadProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbProductClassL) LoadProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		if !queries.IsNil(object.ProductID) {
			args = append(args, object.ProductID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductID) {
				args = append(args, obj.ProductID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_product`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBProduct")
	}

	var resultSlice []*DTBProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBProduct")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_product")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_product")
	}

	if len(dtbProductClassAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Product = foreign
		if foreign.R == nil {
			foreign.R = &dtbProductR{}
		}
		foreign.R.ProductDTBProductClasses = append(foreign.R.ProductDTBProductClasses, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductID, foreign.ID) {
				local.R.Product = foreign
				if foreign.R == nil {
					foreign.R = &dtbProductR{}
				}
				foreign.R.ProductDTBProductClasses = append(foreign.R.ProductDTBProductClasses, local)
				break
			}
		}
	}

	return nil
}

// LoadProductClassDTBProductStocks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbProductClassL) LoadProductClassDTBProductStocks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_product_stock`), qm.WhereIn(`product_class_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_product_stock")
	}

	var resultSlice []*DTBProductStock
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_product_stock")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_product_stock")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_product_stock")
	}

	if len(dtbProductStockAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductClassDTBProductStocks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbProductStockR{}
			}
			foreign.R.ProductClass = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ProductClassID) {
				local.R.ProductClassDTBProductStocks = append(local.R.ProductClassDTBProductStocks, foreign)
				if foreign.R == nil {
					foreign.R = &dtbProductStockR{}
				}
				foreign.R.ProductClass = local
				break
			}
		}
	}

	return nil
}

// SetProduct of the dtbProductClass to the related item.
// Sets o.R.Product to related.
// Adds o to related.R.ProductDTBProductClasses.
func (o *DTBProductClass) SetProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBProduct) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_product_class` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"product_id"}),
		strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductID, related.ID)
	if o.R == nil {
		o.R = &dtbProductClassR{
			Product: related,
		}
	} else {
		o.R.Product = related
	}

	if related.R == nil {
		related.R = &dtbProductR{
			ProductDTBProductClasses: DTBProductClassSlice{o},
		}
	} else {
		related.R.ProductDTBProductClasses = append(related.R.ProductDTBProductClasses, o)
	}

	return nil
}

// RemoveProduct relationship.
// Sets o.R.Product to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBProductClass) RemoveProduct(ctx context.Context, exec boil.ContextExecutor, related *DTBProduct) error {
	var err error

	queries.SetScanner(&o.ProductID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("product_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Product = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ProductDTBProductClasses {
		if queries.Equal(o.ProductID, ri.ProductID) {
			continue
		}

		ln := len(related.R.ProductDTBProductClasses)
		if ln > 1 && i < ln-1 {
			related.R.ProductDTBProductClasses[i] = related.R.ProductDTBProductClasses[ln-1]
		}
		related.R.ProductDTBProductClasses = related.R.ProductDTBProductClasses[:ln-1]
		break
	}
	return nil
}

// AddProductClassDTBProductStocks adds the given related objects to the existing relationships
// of the dtb_product_class, optionally inserting them as new records.
// Appends related to o.R.ProductClassDTBProductStocks.
// Sets related.R.ProductClass appropriately.
func (o *DTBProductClass) AddProductClassDTBProductStocks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductStock) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ProductClassID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_product_stock` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"product_class_id"}),
				strmangle.WhereClause("`", "`", 0, dtbProductStockPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ProductClassID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbProductClassR{
			ProductClassDTBProductStocks: related,
		}
	} else {
		o.R.ProductClassDTBProductStocks = append(o.R.ProductClassDTBProductStocks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbProductStockR{
				ProductClass: o,
			}
		} else {
			rel.R.ProductClass = o
		}
	}
	return nil
}

// SetProductClassDTBProductStocks removes all previously related items of the
// dtb_product_class replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ProductClass's ProductClassDTBProductStocks accordingly.
// Replaces o.R.ProductClassDTBProductStocks with related.
// Sets related.R.ProductClass's ProductClassDTBProductStocks accordingly.
func (o *DTBProductClass) SetProductClassDTBProductStocks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductStock) error {
	query := "update `dtb_product_stock` set `product_class_id` = null where `product_class_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ProductClassDTBProductStocks {
			queries.SetScanner(&rel.ProductClassID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ProductClass = nil
		}

		o.R.ProductClassDTBProductStocks = nil
	}
	return o.AddProductClassDTBProductStocks(ctx, exec, insert, related...)
}

// RemoveProductClassDTBProductStocks relationships from objects passed in.
// Removes related items from R.ProductClassDTBProductStocks (uses pointer comparison, removal does not keep order)
// Sets related.R.ProductClass.
func (o *DTBProductClass) RemoveProductClassDTBProductStocks(ctx context.Context, exec boil.ContextExecutor, related ...*DTBProductStock) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ProductClassID, nil)
		if rel.R != nil {
			rel.R.ProductClass = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("product_class_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ProductClassDTBProductStocks {
			if rel != ri {
				continue
			}

			ln := len(o.R.ProductClassDTBProductStocks)
			if ln > 1 && i < ln-1 {
				o.R.ProductClassDTBProductStocks[i] = o.R.ProductClassDTBProductStocks[ln-1]
			}
			o.R.ProductClassDTBProductStocks = o.R.ProductClassDTBProductStocks[:ln-1]
			break
		}
	}

	return nil
}

// DTBProductClasses retrieves all the records using an executor.
func DTBProductClasses(mods ...qm.QueryMod) dtbProductClassQuery {
	mods = append(mods, qm.From("`dtb_product_class`"))
	return dtbProductClassQuery{NewQuery(mods...)}
}

// FindDTBProductClass retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDTBProductClass(ctx context.Context, exec boil.ContextExecutor, iD uint, selectCols ...string) (*DTBProductClass, error) {
	dtbProductClassObj := &DTBProductClass{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `dtb_product_class` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, dtbProductClassObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from dtb_product_class")
	}

	return dtbProductClassObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DTBProductClass) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_product_class provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbProductClassColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dtbProductClassInsertCacheMut.RLock()
	cache, cached := dtbProductClassInsertCache[key]
	dtbProductClassInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dtbProductClassColumns,
			dtbProductClassColumnsWithDefault,
			dtbProductClassColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `dtb_product_class` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `dtb_product_class` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `dtb_product_class` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into dtb_product_class")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbProductClassMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_product_class")
	}

CacheNoHooks:
	if !cached {
		dtbProductClassInsertCacheMut.Lock()
		dtbProductClassInsertCache[key] = cache
		dtbProductClassInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DTBProductClass.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DTBProductClass) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	dtbProductClassUpdateCacheMut.RLock()
	cache, cached := dtbProductClassUpdateCache[key]
	dtbProductClassUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dtbProductClassColumns,
			dtbProductClassPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("model: unable to update dtb_product_class, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `dtb_product_class` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, append(wl, dtbProductClassPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update dtb_product_class row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by update for dtb_product_class")
	}

	if !cached {
		dtbProductClassUpdateCacheMut.Lock()
		dtbProductClassUpdateCache[key] = cache
		dtbProductClassUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q dtbProductClassQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all for dtb_product_class")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected for dtb_product_class")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DTBProductClassSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbProductClassPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `dtb_product_class` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbProductClassPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all in dtbProductClass slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected all in update all dtbProductClass")
	}
	return rowsAff, nil
}

var mySQLDTBProductClassUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DTBProductClass) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_product_class provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbProductClassColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDTBProductClassUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dtbProductClassUpsertCacheMut.RLock()
	cache, cached := dtbProductClassUpsertCache[key]
	dtbProductClassUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dtbProductClassColumns,
			dtbProductClassColumnsWithDefault,
			dtbProductClassColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			dtbProductClassColumns,
			dtbProductClassPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("model: unable to upsert dtb_product_class, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "dtb_product_class", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `dtb_product_class` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to upsert for dtb_product_class")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbProductClassMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "model: unable to retrieve unique values for dtb_product_class")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_product_class")
	}

CacheNoHooks:
	if !cached {
		dtbProductClassUpsertCacheMut.Lock()
		dtbProductClassUpsertCache[key] = cache
		dtbProductClassUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DTBProductClass record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DTBProductClass) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBProductClass provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dtbProductClassPrimaryKeyMapping)
	sql := "DELETE FROM `dtb_product_class` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete from dtb_product_class")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by delete for dtb_product_class")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q dtbProductClassQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("model: no dtbProductClassQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtb_product_class")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_product_class")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DTBProductClassSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBProductClass slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(dtbProductClassBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbProductClassPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `dtb_product_class` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbProductClassPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtbProductClass slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_product_class")
	}

	if len(dtbProductClassAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DTBProductClass) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDTBProductClass(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DTBProductClassSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DTBProductClassSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbProductClassPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `dtb_product_class`.* FROM `dtb_product_class` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbProductClassPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in DTBProductClassSlice")
	}

	*o = slice

	return nil
}

// DTBProductClassExists checks if the DTBProductClass row exists.
func DTBProductClassExists(ctx context.Context, exec boil.ContextExecutor, iD uint) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `dtb_product_class` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if dtb_product_class exists")
	}

	return exists, nil
}
