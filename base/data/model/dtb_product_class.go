// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// DTBProductClass is an object representing the database table.
type DTBProductClass struct {
	ID                 uint              `boil:"id" json:"id" toml:"id" yaml:"id"`
	ProductID          null.Uint         `boil:"product_id" json:"product_id,omitempty" toml:"product_id" yaml:"product_id,omitempty"`
	SaleTypeID         null.Uint16       `boil:"sale_type_id" json:"sale_type_id,omitempty" toml:"sale_type_id" yaml:"sale_type_id,omitempty"`
	ClassCategoryID1   null.Uint         `boil:"class_category_id1" json:"class_category_id1,omitempty" toml:"class_category_id1" yaml:"class_category_id1,omitempty"`
	ClassCategoryID2   null.Uint         `boil:"class_category_id2" json:"class_category_id2,omitempty" toml:"class_category_id2" yaml:"class_category_id2,omitempty"`
	DeliveryDurationID null.Uint         `boil:"delivery_duration_id" json:"delivery_duration_id,omitempty" toml:"delivery_duration_id" yaml:"delivery_duration_id,omitempty"`
	CreatorID          null.Uint         `boil:"creator_id" json:"creator_id,omitempty" toml:"creator_id" yaml:"creator_id,omitempty"`
	ProductCode        null.String       `boil:"product_code" json:"product_code,omitempty" toml:"product_code" yaml:"product_code,omitempty"`
	Stock              types.NullDecimal `boil:"stock" json:"stock,omitempty" toml:"stock" yaml:"stock,omitempty"`
	StockUnlimited     bool              `boil:"stock_unlimited" json:"stock_unlimited" toml:"stock_unlimited" yaml:"stock_unlimited"`
	SaleLimit          types.NullDecimal `boil:"sale_limit" json:"sale_limit,omitempty" toml:"sale_limit" yaml:"sale_limit,omitempty"`
	Price01            types.NullDecimal `boil:"price01" json:"price01,omitempty" toml:"price01" yaml:"price01,omitempty"`
	Price02            types.Decimal     `boil:"price02" json:"price02" toml:"price02" yaml:"price02"`
	DeliveryFee        types.NullDecimal `boil:"delivery_fee" json:"delivery_fee,omitempty" toml:"delivery_fee" yaml:"delivery_fee,omitempty"`
	Visible            bool              `boil:"visible" json:"visible" toml:"visible" yaml:"visible"`
	CreateDate         time.Time         `boil:"create_date" json:"create_date" toml:"create_date" yaml:"create_date"`
	UpdateDate         time.Time         `boil:"update_date" json:"update_date" toml:"update_date" yaml:"update_date"`
	CurrencyCode       null.String       `boil:"currency_code" json:"currency_code,omitempty" toml:"currency_code" yaml:"currency_code,omitempty"`
	PointRate          types.NullDecimal `boil:"point_rate" json:"point_rate,omitempty" toml:"point_rate" yaml:"point_rate,omitempty"`
	DiscriminatorType  string            `boil:"discriminator_type" json:"discriminator_type" toml:"discriminator_type" yaml:"discriminator_type"`

	R *dtbProductClassR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dtbProductClassL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DTBProductClassColumns = struct {
	ID                 string
	ProductID          string
	SaleTypeID         string
	ClassCategoryID1   string
	ClassCategoryID2   string
	DeliveryDurationID string
	CreatorID          string
	ProductCode        string
	Stock              string
	StockUnlimited     string
	SaleLimit          string
	Price01            string
	Price02            string
	DeliveryFee        string
	Visible            string
	CreateDate         string
	UpdateDate         string
	CurrencyCode       string
	PointRate          string
	DiscriminatorType  string
}{
	ID:                 "id",
	ProductID:          "product_id",
	SaleTypeID:         "sale_type_id",
	ClassCategoryID1:   "class_category_id1",
	ClassCategoryID2:   "class_category_id2",
	DeliveryDurationID: "delivery_duration_id",
	CreatorID:          "creator_id",
	ProductCode:        "product_code",
	Stock:              "stock",
	StockUnlimited:     "stock_unlimited",
	SaleLimit:          "sale_limit",
	Price01:            "price01",
	Price02:            "price02",
	DeliveryFee:        "delivery_fee",
	Visible:            "visible",
	CreateDate:         "create_date",
	UpdateDate:         "update_date",
	CurrencyCode:       "currency_code",
	PointRate:          "point_rate",
	DiscriminatorType:  "discriminator_type",
}

// Generated where

var DTBProductClassWhere = struct {
	ID                 whereHelperuint
	ProductID          whereHelpernull_Uint
	SaleTypeID         whereHelpernull_Uint16
	ClassCategoryID1   whereHelpernull_Uint
	ClassCategoryID2   whereHelpernull_Uint
	DeliveryDurationID whereHelpernull_Uint
	CreatorID          whereHelpernull_Uint
	ProductCode        whereHelpernull_String
	Stock              whereHelpertypes_NullDecimal
	StockUnlimited     whereHelperbool
	SaleLimit          whereHelpertypes_NullDecimal
	Price01            whereHelpertypes_NullDecimal
	Price02            whereHelpertypes_Decimal
	DeliveryFee        whereHelpertypes_NullDecimal
	Visible            whereHelperbool
	CreateDate         whereHelpertime_Time
	UpdateDate         whereHelpertime_Time
	CurrencyCode       whereHelpernull_String
	PointRate          whereHelpertypes_NullDecimal
	DiscriminatorType  whereHelperstring
}{
	ID:                 whereHelperuint{field: `id`},
	ProductID:          whereHelpernull_Uint{field: `product_id`},
	SaleTypeID:         whereHelpernull_Uint16{field: `sale_type_id`},
	ClassCategoryID1:   whereHelpernull_Uint{field: `class_category_id1`},
	ClassCategoryID2:   whereHelpernull_Uint{field: `class_category_id2`},
	DeliveryDurationID: whereHelpernull_Uint{field: `delivery_duration_id`},
	CreatorID:          whereHelpernull_Uint{field: `creator_id`},
	ProductCode:        whereHelpernull_String{field: `product_code`},
	Stock:              whereHelpertypes_NullDecimal{field: `stock`},
	StockUnlimited:     whereHelperbool{field: `stock_unlimited`},
	SaleLimit:          whereHelpertypes_NullDecimal{field: `sale_limit`},
	Price01:            whereHelpertypes_NullDecimal{field: `price01`},
	Price02:            whereHelpertypes_Decimal{field: `price02`},
	DeliveryFee:        whereHelpertypes_NullDecimal{field: `delivery_fee`},
	Visible:            whereHelperbool{field: `visible`},
	CreateDate:         whereHelpertime_Time{field: `create_date`},
	UpdateDate:         whereHelpertime_Time{field: `update_date`},
	CurrencyCode:       whereHelpernull_String{field: `currency_code`},
	PointRate:          whereHelpertypes_NullDecimal{field: `point_rate`},
	DiscriminatorType:  whereHelperstring{field: `discriminator_type`},
}

// DTBProductClassRels is where relationship names are stored.
var DTBProductClassRels = struct {
	ClassCategoryID1             string
	Product                      string
	Creator                      string
	ClassCategoryID2             string
	SaleType                     string
	DeliveryDuration             string
	ProductClassDTBCartItems     string
	ProductClassDTBOrderItems    string
	ProductClassDTBProductStocks string
	ProductClassDTBTaxRules      string
}{
	ClassCategoryID1:             "ClassCategoryID1",
	Product:                      "Product",
	Creator:                      "Creator",
	ClassCategoryID2:             "ClassCategoryID2",
	SaleType:                     "SaleType",
	DeliveryDuration:             "DeliveryDuration",
	ProductClassDTBCartItems:     "ProductClassDTBCartItems",
	ProductClassDTBOrderItems:    "ProductClassDTBOrderItems",
	ProductClassDTBProductStocks: "ProductClassDTBProductStocks",
	ProductClassDTBTaxRules:      "ProductClassDTBTaxRules",
}

// dtbProductClassR is where relationships are stored.
type dtbProductClassR struct {
	ClassCategoryID1             *DTBClassCategory
	Product                      *DTBProduct
	Creator                      *DTBMember
	ClassCategoryID2             *DTBClassCategory
	SaleType                     *MTBSaleType
	DeliveryDuration             *DTBDeliveryDuration
	ProductClassDTBCartItems     DTBCartItemSlice
	ProductClassDTBOrderItems    DTBOrderItemSlice
	ProductClassDTBProductStocks DTBProductStockSlice
	ProductClassDTBTaxRules      DTBTaxRuleSlice
}

// NewStruct creates a new relationship struct
func (*dtbProductClassR) NewStruct() *dtbProductClassR {
	return &dtbProductClassR{}
}

// dtbProductClassL is where Load methods for each relationship are stored.
type dtbProductClassL struct{}

var (
	dtbProductClassColumns               = []string{"id", "product_id", "sale_type_id", "class_category_id1", "class_category_id2", "delivery_duration_id", "creator_id", "product_code", "stock", "stock_unlimited", "sale_limit", "price01", "price02", "delivery_fee", "visible", "create_date", "update_date", "currency_code", "point_rate", "discriminator_type"}
	dtbProductClassColumnsWithoutDefault = []string{"product_id", "sale_type_id", "class_category_id1", "class_category_id2", "delivery_duration_id", "creator_id", "product_code", "stock", "sale_limit", "price01", "price02", "delivery_fee", "create_date", "update_date", "currency_code", "point_rate", "discriminator_type"}
	dtbProductClassColumnsWithDefault    = []string{"id", "stock_unlimited", "visible"}
	dtbProductClassPrimaryKeyColumns     = []string{"id"}
)

type (
	// DTBProductClassSlice is an alias for a slice of pointers to DTBProductClass.
	// This should generally be used opposed to []DTBProductClass.
	DTBProductClassSlice []*DTBProductClass
	// DTBProductClassHook is the signature for custom DTBProductClass hook methods
	DTBProductClassHook func(context.Context, boil.ContextExecutor, *DTBProductClass) error

	dtbProductClassQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dtbProductClassType                 = reflect.TypeOf(&DTBProductClass{})
	dtbProductClassMapping              = queries.MakeStructMapping(dtbProductClassType)
	dtbProductClassPrimaryKeyMapping, _ = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, dtbProductClassPrimaryKeyColumns)
	dtbProductClassInsertCacheMut       sync.RWMutex
	dtbProductClassInsertCache          = make(map[string]insertCache)
	dtbProductClassUpdateCacheMut       sync.RWMutex
	dtbProductClassUpdateCache          = make(map[string]updateCache)
	dtbProductClassUpsertCacheMut       sync.RWMutex
	dtbProductClassUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var dtbProductClassBeforeInsertHooks []DTBProductClassHook
var dtbProductClassBeforeUpdateHooks []DTBProductClassHook
var dtbProductClassBeforeDeleteHooks []DTBProductClassHook
var dtbProductClassBeforeUpsertHooks []DTBProductClassHook

var dtbProductClassAfterInsertHooks []DTBProductClassHook
var dtbProductClassAfterSelectHooks []DTBProductClassHook
var dtbProductClassAfterUpdateHooks []DTBProductClassHook
var dtbProductClassAfterDeleteHooks []DTBProductClassHook
var dtbProductClassAfterUpsertHooks []DTBProductClassHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DTBProductClass) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DTBProductClass) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DTBProductClass) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DTBProductClass) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DTBProductClass) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DTBProductClass) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DTBProductClass) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DTBProductClass) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DTBProductClass) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbProductClassAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDTBProductClassHook registers your hook function for all future operations.
func AddDTBProductClassHook(hookPoint boil.HookPoint, dtbProductClassHook DTBProductClassHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		dtbProductClassBeforeInsertHooks = append(dtbProductClassBeforeInsertHooks, dtbProductClassHook)
	case boil.BeforeUpdateHook:
		dtbProductClassBeforeUpdateHooks = append(dtbProductClassBeforeUpdateHooks, dtbProductClassHook)
	case boil.BeforeDeleteHook:
		dtbProductClassBeforeDeleteHooks = append(dtbProductClassBeforeDeleteHooks, dtbProductClassHook)
	case boil.BeforeUpsertHook:
		dtbProductClassBeforeUpsertHooks = append(dtbProductClassBeforeUpsertHooks, dtbProductClassHook)
	case boil.AfterInsertHook:
		dtbProductClassAfterInsertHooks = append(dtbProductClassAfterInsertHooks, dtbProductClassHook)
	case boil.AfterSelectHook:
		dtbProductClassAfterSelectHooks = append(dtbProductClassAfterSelectHooks, dtbProductClassHook)
	case boil.AfterUpdateHook:
		dtbProductClassAfterUpdateHooks = append(dtbProductClassAfterUpdateHooks, dtbProductClassHook)
	case boil.AfterDeleteHook:
		dtbProductClassAfterDeleteHooks = append(dtbProductClassAfterDeleteHooks, dtbProductClassHook)
	case boil.AfterUpsertHook:
		dtbProductClassAfterUpsertHooks = append(dtbProductClassAfterUpsertHooks, dtbProductClassHook)
	}
}

// One returns a single dtbProductClass record from the query.
func (q dtbProductClassQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DTBProductClass, error) {
	o := &DTBProductClass{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for dtb_product_class")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DTBProductClass records from the query.
func (q dtbProductClassQuery) All(ctx context.Context, exec boil.ContextExecutor) (DTBProductClassSlice, error) {
	var o []*DTBProductClass

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to DTBProductClass slice")
	}

	if len(dtbProductClassAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DTBProductClass records in the query.
func (q dtbProductClassQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count dtb_product_class rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dtbProductClassQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if dtb_product_class exists")
	}

	return count > 0, nil
}

// ClassCategoryID1 pointed to by the foreign key.
func (o *DTBProductClass) ClassCategoryID1(mods ...qm.QueryMod) dtbClassCategoryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.ClassCategoryID1),
	}

	queryMods = append(queryMods, mods...)

	query := DTBClassCategories(queryMods...)
	queries.SetFrom(query.Query, "`dtb_class_category`")

	return query
}

// Product pointed to by the foreign key.
func (o *DTBProductClass) Product(mods ...qm.QueryMod) dtbProductQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.ProductID),
	}

	queryMods = append(queryMods, mods...)

	query := DTBProducts(queryMods...)
	queries.SetFrom(query.Query, "`dtb_product`")

	return query
}

// Creator pointed to by the foreign key.
func (o *DTBProductClass) Creator(mods ...qm.QueryMod) dtbMemberQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.CreatorID),
	}

	queryMods = append(queryMods, mods...)

	query := DTBMembers(queryMods...)
	queries.SetFrom(query.Query, "`dtb_member`")

	return query
}

// ClassCategoryID2 pointed to by the foreign key.
func (o *DTBProductClass) ClassCategoryID2(mods ...qm.QueryMod) dtbClassCategoryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.ClassCategoryID2),
	}

	queryMods = append(queryMods, mods...)

	query := DTBClassCategories(queryMods...)
	queries.SetFrom(query.Query, "`dtb_class_category`")

	return query
}

// SaleType pointed to by the foreign key.
func (o *DTBProductClass) SaleType(mods ...qm.QueryMod) mtbSaleTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.SaleTypeID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBSaleTypes(queryMods...)
	queries.SetFrom(query.Query, "`mtb_sale_type`")

	return query
}

// DeliveryDuration pointed to by the foreign key.
func (o *DTBProductClass) DeliveryDuration(mods ...qm.QueryMod) dtbDeliveryDurationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.DeliveryDurationID),
	}

	queryMods = append(queryMods, mods...)

	query := DTBDeliveryDurations(queryMods...)
	queries.SetFrom(query.Query, "`dtb_delivery_duration`")

	return query
}

// ProductClassDTBCartItems retrieves all the dtb_cart_item's DTBCartItems with an executor via product_class_id column.
func (o *DTBProductClass) ProductClassDTBCartItems(mods ...qm.QueryMod) dtbCartItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_cart_item`.`product_class_id`=?", o.ID),
	)

	query := DTBCartItems(queryMods...)
	queries.SetFrom(query.Query, "`dtb_cart_item`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_cart_item`.*"})
	}

	return query
}

// ProductClassDTBOrderItems retrieves all the dtb_order_item's DTBOrderItems with an executor via product_class_id column.
func (o *DTBProductClass) ProductClassDTBOrderItems(mods ...qm.QueryMod) dtbOrderItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_order_item`.`product_class_id`=?", o.ID),
	)

	query := DTBOrderItems(queryMods...)
	queries.SetFrom(query.Query, "`dtb_order_item`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_order_item`.*"})
	}

	return query
}

// ProductClassDTBProductStocks retrieves all the dtb_product_stock's DTBProductStocks with an executor via product_class_id column.
func (o *DTBProductClass) ProductClassDTBProductStocks(mods ...qm.QueryMod) dtbProductStockQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_product_stock`.`product_class_id`=?", o.ID),
	)

	query := DTBProductStocks(queryMods...)
	queries.SetFrom(query.Query, "`dtb_product_stock`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_product_stock`.*"})
	}

	return query
}

// ProductClassDTBTaxRules retrieves all the dtb_tax_rule's DTBTaxRules with an executor via product_class_id column.
func (o *DTBProductClass) ProductClassDTBTaxRules(mods ...qm.QueryMod) dtbTaxRuleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_tax_rule`.`product_class_id`=?", o.ID),
	)

	query := DTBTaxRules(queryMods...)
	queries.SetFrom(query.Query, "`dtb_tax_rule`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_tax_rule`.*"})
	}

	return query
}

// LoadClassCategoryID1 allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbProductClassL) LoadClassCategoryID1(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		if !queries.IsNil(object.ClassCategoryID1) {
			args = append(args, object.ClassCategoryID1)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ClassCategoryID1) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ClassCategoryID1) {
				args = append(args, obj.ClassCategoryID1)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_class_category`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBClassCategory")
	}

	var resultSlice []*DTBClassCategory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBClassCategory")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_class_category")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_class_category")
	}

	if len(dtbProductClassAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ClassCategoryID1 = foreign
		if foreign.R == nil {
			foreign.R = &dtbClassCategoryR{}
		}
		foreign.R.ClassCategoryID1DTBProductClasses = append(foreign.R.ClassCategoryID1DTBProductClasses, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ClassCategoryID1, foreign.ID) {
				local.R.ClassCategoryID1 = foreign
				if foreign.R == nil {
					foreign.R = &dtbClassCategoryR{}
				}
				foreign.R.ClassCategoryID1DTBProductClasses = append(foreign.R.ClassCategoryID1DTBProductClasses, local)
				break
			}
		}
	}

	return nil
}

// LoadProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbProductClassL) LoadProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		if !queries.IsNil(object.ProductID) {
			args = append(args, object.ProductID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductID) {
				args = append(args, obj.ProductID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_product`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBProduct")
	}

	var resultSlice []*DTBProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBProduct")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_product")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_product")
	}

	if len(dtbProductClassAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Product = foreign
		if foreign.R == nil {
			foreign.R = &dtbProductR{}
		}
		foreign.R.ProductDTBProductClasses = append(foreign.R.ProductDTBProductClasses, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductID, foreign.ID) {
				local.R.Product = foreign
				if foreign.R == nil {
					foreign.R = &dtbProductR{}
				}
				foreign.R.ProductDTBProductClasses = append(foreign.R.ProductDTBProductClasses, local)
				break
			}
		}
	}

	return nil
}

// LoadCreator allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbProductClassL) LoadCreator(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		if !queries.IsNil(object.CreatorID) {
			args = append(args, object.CreatorID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CreatorID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CreatorID) {
				args = append(args, obj.CreatorID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_member`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBMember")
	}

	var resultSlice []*DTBMember
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBMember")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_member")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_member")
	}

	if len(dtbProductClassAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Creator = foreign
		if foreign.R == nil {
			foreign.R = &dtbMemberR{}
		}
		foreign.R.CreatorDTBProductClasses = append(foreign.R.CreatorDTBProductClasses, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CreatorID, foreign.ID) {
				local.R.Creator = foreign
				if foreign.R == nil {
					foreign.R = &dtbMemberR{}
				}
				foreign.R.CreatorDTBProductClasses = append(foreign.R.CreatorDTBProductClasses, local)
				break
			}
		}
	}

	return nil
}

// LoadClassCategoryID2 allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbProductClassL) LoadClassCategoryID2(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		if !queries.IsNil(object.ClassCategoryID2) {
			args = append(args, object.ClassCategoryID2)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ClassCategoryID2) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ClassCategoryID2) {
				args = append(args, obj.ClassCategoryID2)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_class_category`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBClassCategory")
	}

	var resultSlice []*DTBClassCategory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBClassCategory")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_class_category")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_class_category")
	}

	if len(dtbProductClassAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ClassCategoryID2 = foreign
		if foreign.R == nil {
			foreign.R = &dtbClassCategoryR{}
		}
		foreign.R.ClassCategoryID2DTBProductClasses = append(foreign.R.ClassCategoryID2DTBProductClasses, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ClassCategoryID2, foreign.ID) {
				local.R.ClassCategoryID2 = foreign
				if foreign.R == nil {
					foreign.R = &dtbClassCategoryR{}
				}
				foreign.R.ClassCategoryID2DTBProductClasses = append(foreign.R.ClassCategoryID2DTBProductClasses, local)
				break
			}
		}
	}

	return nil
}

// LoadSaleType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbProductClassL) LoadSaleType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		if !queries.IsNil(object.SaleTypeID) {
			args = append(args, object.SaleTypeID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.SaleTypeID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.SaleTypeID) {
				args = append(args, obj.SaleTypeID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_sale_type`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBSaleType")
	}

	var resultSlice []*MTBSaleType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBSaleType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_sale_type")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_sale_type")
	}

	if len(dtbProductClassAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SaleType = foreign
		if foreign.R == nil {
			foreign.R = &mtbSaleTypeR{}
		}
		foreign.R.SaleTypeDTBProductClasses = append(foreign.R.SaleTypeDTBProductClasses, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SaleTypeID, foreign.ID) {
				local.R.SaleType = foreign
				if foreign.R == nil {
					foreign.R = &mtbSaleTypeR{}
				}
				foreign.R.SaleTypeDTBProductClasses = append(foreign.R.SaleTypeDTBProductClasses, local)
				break
			}
		}
	}

	return nil
}

// LoadDeliveryDuration allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbProductClassL) LoadDeliveryDuration(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		if !queries.IsNil(object.DeliveryDurationID) {
			args = append(args, object.DeliveryDurationID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliveryDurationID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliveryDurationID) {
				args = append(args, obj.DeliveryDurationID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_delivery_duration`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBDeliveryDuration")
	}

	var resultSlice []*DTBDeliveryDuration
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBDeliveryDuration")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_delivery_duration")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_delivery_duration")
	}

	if len(dtbProductClassAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliveryDuration = foreign
		if foreign.R == nil {
			foreign.R = &dtbDeliveryDurationR{}
		}
		foreign.R.DeliveryDurationDTBProductClasses = append(foreign.R.DeliveryDurationDTBProductClasses, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliveryDurationID, foreign.ID) {
				local.R.DeliveryDuration = foreign
				if foreign.R == nil {
					foreign.R = &dtbDeliveryDurationR{}
				}
				foreign.R.DeliveryDurationDTBProductClasses = append(foreign.R.DeliveryDurationDTBProductClasses, local)
				break
			}
		}
	}

	return nil
}

// LoadProductClassDTBCartItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbProductClassL) LoadProductClassDTBCartItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_cart_item`), qm.WhereIn(`product_class_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_cart_item")
	}

	var resultSlice []*DTBCartItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_cart_item")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_cart_item")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_cart_item")
	}

	if len(dtbCartItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductClassDTBCartItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbCartItemR{}
			}
			foreign.R.ProductClass = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ProductClassID) {
				local.R.ProductClassDTBCartItems = append(local.R.ProductClassDTBCartItems, foreign)
				if foreign.R == nil {
					foreign.R = &dtbCartItemR{}
				}
				foreign.R.ProductClass = local
				break
			}
		}
	}

	return nil
}

// LoadProductClassDTBOrderItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbProductClassL) LoadProductClassDTBOrderItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_order_item`), qm.WhereIn(`product_class_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_order_item")
	}

	var resultSlice []*DTBOrderItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_order_item")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_order_item")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_order_item")
	}

	if len(dtbOrderItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductClassDTBOrderItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbOrderItemR{}
			}
			foreign.R.ProductClass = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ProductClassID) {
				local.R.ProductClassDTBOrderItems = append(local.R.ProductClassDTBOrderItems, foreign)
				if foreign.R == nil {
					foreign.R = &dtbOrderItemR{}
				}
				foreign.R.ProductClass = local
				break
			}
		}
	}

	return nil
}

// LoadProductClassDTBProductStocks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbProductClassL) LoadProductClassDTBProductStocks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_product_stock`), qm.WhereIn(`product_class_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_product_stock")
	}

	var resultSlice []*DTBProductStock
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_product_stock")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_product_stock")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_product_stock")
	}

	if len(dtbProductStockAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductClassDTBProductStocks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbProductStockR{}
			}
			foreign.R.ProductClass = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ProductClassID) {
				local.R.ProductClassDTBProductStocks = append(local.R.ProductClassDTBProductStocks, foreign)
				if foreign.R == nil {
					foreign.R = &dtbProductStockR{}
				}
				foreign.R.ProductClass = local
				break
			}
		}
	}

	return nil
}

// LoadProductClassDTBTaxRules allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbProductClassL) LoadProductClassDTBTaxRules(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBProductClass interface{}, mods queries.Applicator) error {
	var slice []*DTBProductClass
	var object *DTBProductClass

	if singular {
		object = maybeDTBProductClass.(*DTBProductClass)
	} else {
		slice = *maybeDTBProductClass.(*[]*DTBProductClass)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbProductClassR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbProductClassR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_tax_rule`), qm.WhereIn(`product_class_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_tax_rule")
	}

	var resultSlice []*DTBTaxRule
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_tax_rule")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_tax_rule")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_tax_rule")
	}

	if len(dtbTaxRuleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductClassDTBTaxRules = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbTaxRuleR{}
			}
			foreign.R.ProductClass = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ProductClassID) {
				local.R.ProductClassDTBTaxRules = append(local.R.ProductClassDTBTaxRules, foreign)
				if foreign.R == nil {
					foreign.R = &dtbTaxRuleR{}
				}
				foreign.R.ProductClass = local
				break
			}
		}
	}

	return nil
}

// SetClassCategoryID1 of the dtbProductClass to the related item.
// Sets o.R.ClassCategoryID1 to related.
// Adds o to related.R.ClassCategoryID1DTBProductClasses.
func (o *DTBProductClass) SetClassCategoryID1(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBClassCategory) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_product_class` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"class_category_id1"}),
		strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ClassCategoryID1, related.ID)
	if o.R == nil {
		o.R = &dtbProductClassR{
			ClassCategoryID1: related,
		}
	} else {
		o.R.ClassCategoryID1 = related
	}

	if related.R == nil {
		related.R = &dtbClassCategoryR{
			ClassCategoryID1DTBProductClasses: DTBProductClassSlice{o},
		}
	} else {
		related.R.ClassCategoryID1DTBProductClasses = append(related.R.ClassCategoryID1DTBProductClasses, o)
	}

	return nil
}

// RemoveClassCategoryID1 relationship.
// Sets o.R.ClassCategoryID1 to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBProductClass) RemoveClassCategoryID1(ctx context.Context, exec boil.ContextExecutor, related *DTBClassCategory) error {
	var err error

	queries.SetScanner(&o.ClassCategoryID1, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("class_category_id1")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.ClassCategoryID1 = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ClassCategoryID1DTBProductClasses {
		if queries.Equal(o.ClassCategoryID1, ri.ClassCategoryID1) {
			continue
		}

		ln := len(related.R.ClassCategoryID1DTBProductClasses)
		if ln > 1 && i < ln-1 {
			related.R.ClassCategoryID1DTBProductClasses[i] = related.R.ClassCategoryID1DTBProductClasses[ln-1]
		}
		related.R.ClassCategoryID1DTBProductClasses = related.R.ClassCategoryID1DTBProductClasses[:ln-1]
		break
	}
	return nil
}

// SetProduct of the dtbProductClass to the related item.
// Sets o.R.Product to related.
// Adds o to related.R.ProductDTBProductClasses.
func (o *DTBProductClass) SetProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBProduct) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_product_class` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"product_id"}),
		strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductID, related.ID)
	if o.R == nil {
		o.R = &dtbProductClassR{
			Product: related,
		}
	} else {
		o.R.Product = related
	}

	if related.R == nil {
		related.R = &dtbProductR{
			ProductDTBProductClasses: DTBProductClassSlice{o},
		}
	} else {
		related.R.ProductDTBProductClasses = append(related.R.ProductDTBProductClasses, o)
	}

	return nil
}

// RemoveProduct relationship.
// Sets o.R.Product to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBProductClass) RemoveProduct(ctx context.Context, exec boil.ContextExecutor, related *DTBProduct) error {
	var err error

	queries.SetScanner(&o.ProductID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("product_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Product = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ProductDTBProductClasses {
		if queries.Equal(o.ProductID, ri.ProductID) {
			continue
		}

		ln := len(related.R.ProductDTBProductClasses)
		if ln > 1 && i < ln-1 {
			related.R.ProductDTBProductClasses[i] = related.R.ProductDTBProductClasses[ln-1]
		}
		related.R.ProductDTBProductClasses = related.R.ProductDTBProductClasses[:ln-1]
		break
	}
	return nil
}

// SetCreator of the dtbProductClass to the related item.
// Sets o.R.Creator to related.
// Adds o to related.R.CreatorDTBProductClasses.
func (o *DTBProductClass) SetCreator(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBMember) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_product_class` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
		strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CreatorID, related.ID)
	if o.R == nil {
		o.R = &dtbProductClassR{
			Creator: related,
		}
	} else {
		o.R.Creator = related
	}

	if related.R == nil {
		related.R = &dtbMemberR{
			CreatorDTBProductClasses: DTBProductClassSlice{o},
		}
	} else {
		related.R.CreatorDTBProductClasses = append(related.R.CreatorDTBProductClasses, o)
	}

	return nil
}

// RemoveCreator relationship.
// Sets o.R.Creator to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBProductClass) RemoveCreator(ctx context.Context, exec boil.ContextExecutor, related *DTBMember) error {
	var err error

	queries.SetScanner(&o.CreatorID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Creator = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CreatorDTBProductClasses {
		if queries.Equal(o.CreatorID, ri.CreatorID) {
			continue
		}

		ln := len(related.R.CreatorDTBProductClasses)
		if ln > 1 && i < ln-1 {
			related.R.CreatorDTBProductClasses[i] = related.R.CreatorDTBProductClasses[ln-1]
		}
		related.R.CreatorDTBProductClasses = related.R.CreatorDTBProductClasses[:ln-1]
		break
	}
	return nil
}

// SetClassCategoryID2 of the dtbProductClass to the related item.
// Sets o.R.ClassCategoryID2 to related.
// Adds o to related.R.ClassCategoryID2DTBProductClasses.
func (o *DTBProductClass) SetClassCategoryID2(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBClassCategory) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_product_class` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"class_category_id2"}),
		strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ClassCategoryID2, related.ID)
	if o.R == nil {
		o.R = &dtbProductClassR{
			ClassCategoryID2: related,
		}
	} else {
		o.R.ClassCategoryID2 = related
	}

	if related.R == nil {
		related.R = &dtbClassCategoryR{
			ClassCategoryID2DTBProductClasses: DTBProductClassSlice{o},
		}
	} else {
		related.R.ClassCategoryID2DTBProductClasses = append(related.R.ClassCategoryID2DTBProductClasses, o)
	}

	return nil
}

// RemoveClassCategoryID2 relationship.
// Sets o.R.ClassCategoryID2 to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBProductClass) RemoveClassCategoryID2(ctx context.Context, exec boil.ContextExecutor, related *DTBClassCategory) error {
	var err error

	queries.SetScanner(&o.ClassCategoryID2, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("class_category_id2")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.ClassCategoryID2 = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ClassCategoryID2DTBProductClasses {
		if queries.Equal(o.ClassCategoryID2, ri.ClassCategoryID2) {
			continue
		}

		ln := len(related.R.ClassCategoryID2DTBProductClasses)
		if ln > 1 && i < ln-1 {
			related.R.ClassCategoryID2DTBProductClasses[i] = related.R.ClassCategoryID2DTBProductClasses[ln-1]
		}
		related.R.ClassCategoryID2DTBProductClasses = related.R.ClassCategoryID2DTBProductClasses[:ln-1]
		break
	}
	return nil
}

// SetSaleType of the dtbProductClass to the related item.
// Sets o.R.SaleType to related.
// Adds o to related.R.SaleTypeDTBProductClasses.
func (o *DTBProductClass) SetSaleType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBSaleType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_product_class` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"sale_type_id"}),
		strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SaleTypeID, related.ID)
	if o.R == nil {
		o.R = &dtbProductClassR{
			SaleType: related,
		}
	} else {
		o.R.SaleType = related
	}

	if related.R == nil {
		related.R = &mtbSaleTypeR{
			SaleTypeDTBProductClasses: DTBProductClassSlice{o},
		}
	} else {
		related.R.SaleTypeDTBProductClasses = append(related.R.SaleTypeDTBProductClasses, o)
	}

	return nil
}

// RemoveSaleType relationship.
// Sets o.R.SaleType to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBProductClass) RemoveSaleType(ctx context.Context, exec boil.ContextExecutor, related *MTBSaleType) error {
	var err error

	queries.SetScanner(&o.SaleTypeID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("sale_type_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.SaleType = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.SaleTypeDTBProductClasses {
		if queries.Equal(o.SaleTypeID, ri.SaleTypeID) {
			continue
		}

		ln := len(related.R.SaleTypeDTBProductClasses)
		if ln > 1 && i < ln-1 {
			related.R.SaleTypeDTBProductClasses[i] = related.R.SaleTypeDTBProductClasses[ln-1]
		}
		related.R.SaleTypeDTBProductClasses = related.R.SaleTypeDTBProductClasses[:ln-1]
		break
	}
	return nil
}

// SetDeliveryDuration of the dtbProductClass to the related item.
// Sets o.R.DeliveryDuration to related.
// Adds o to related.R.DeliveryDurationDTBProductClasses.
func (o *DTBProductClass) SetDeliveryDuration(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBDeliveryDuration) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_product_class` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"delivery_duration_id"}),
		strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliveryDurationID, related.ID)
	if o.R == nil {
		o.R = &dtbProductClassR{
			DeliveryDuration: related,
		}
	} else {
		o.R.DeliveryDuration = related
	}

	if related.R == nil {
		related.R = &dtbDeliveryDurationR{
			DeliveryDurationDTBProductClasses: DTBProductClassSlice{o},
		}
	} else {
		related.R.DeliveryDurationDTBProductClasses = append(related.R.DeliveryDurationDTBProductClasses, o)
	}

	return nil
}

// RemoveDeliveryDuration relationship.
// Sets o.R.DeliveryDuration to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBProductClass) RemoveDeliveryDuration(ctx context.Context, exec boil.ContextExecutor, related *DTBDeliveryDuration) error {
	var err error

	queries.SetScanner(&o.DeliveryDurationID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("delivery_duration_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.DeliveryDuration = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DeliveryDurationDTBProductClasses {
		if queries.Equal(o.DeliveryDurationID, ri.DeliveryDurationID) {
			continue
		}

		ln := len(related.R.DeliveryDurationDTBProductClasses)
		if ln > 1 && i < ln-1 {
			related.R.DeliveryDurationDTBProductClasses[i] = related.R.DeliveryDurationDTBProductClasses[ln-1]
		}
		related.R.DeliveryDurationDTBProductClasses = related.R.DeliveryDurationDTBProductClasses[:ln-1]
		break
	}
	return nil
}

// AddProductClassDTBCartItems adds the given related objects to the existing relationships
// of the dtb_product_class, optionally inserting them as new records.
// Appends related to o.R.ProductClassDTBCartItems.
// Sets related.R.ProductClass appropriately.
func (o *DTBProductClass) AddProductClassDTBCartItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCartItem) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ProductClassID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_cart_item` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"product_class_id"}),
				strmangle.WhereClause("`", "`", 0, dtbCartItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ProductClassID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbProductClassR{
			ProductClassDTBCartItems: related,
		}
	} else {
		o.R.ProductClassDTBCartItems = append(o.R.ProductClassDTBCartItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbCartItemR{
				ProductClass: o,
			}
		} else {
			rel.R.ProductClass = o
		}
	}
	return nil
}

// SetProductClassDTBCartItems removes all previously related items of the
// dtb_product_class replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ProductClass's ProductClassDTBCartItems accordingly.
// Replaces o.R.ProductClassDTBCartItems with related.
// Sets related.R.ProductClass's ProductClassDTBCartItems accordingly.
func (o *DTBProductClass) SetProductClassDTBCartItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCartItem) error {
	query := "update `dtb_cart_item` set `product_class_id` = null where `product_class_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ProductClassDTBCartItems {
			queries.SetScanner(&rel.ProductClassID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ProductClass = nil
		}

		o.R.ProductClassDTBCartItems = nil
	}
	return o.AddProductClassDTBCartItems(ctx, exec, insert, related...)
}

// RemoveProductClassDTBCartItems relationships from objects passed in.
// Removes related items from R.ProductClassDTBCartItems (uses pointer comparison, removal does not keep order)
// Sets related.R.ProductClass.
func (o *DTBProductClass) RemoveProductClassDTBCartItems(ctx context.Context, exec boil.ContextExecutor, related ...*DTBCartItem) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ProductClassID, nil)
		if rel.R != nil {
			rel.R.ProductClass = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("product_class_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ProductClassDTBCartItems {
			if rel != ri {
				continue
			}

			ln := len(o.R.ProductClassDTBCartItems)
			if ln > 1 && i < ln-1 {
				o.R.ProductClassDTBCartItems[i] = o.R.ProductClassDTBCartItems[ln-1]
			}
			o.R.ProductClassDTBCartItems = o.R.ProductClassDTBCartItems[:ln-1]
			break
		}
	}

	return nil
}

// AddProductClassDTBOrderItems adds the given related objects to the existing relationships
// of the dtb_product_class, optionally inserting them as new records.
// Appends related to o.R.ProductClassDTBOrderItems.
// Sets related.R.ProductClass appropriately.
func (o *DTBProductClass) AddProductClassDTBOrderItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBOrderItem) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ProductClassID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_order_item` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"product_class_id"}),
				strmangle.WhereClause("`", "`", 0, dtbOrderItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ProductClassID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbProductClassR{
			ProductClassDTBOrderItems: related,
		}
	} else {
		o.R.ProductClassDTBOrderItems = append(o.R.ProductClassDTBOrderItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbOrderItemR{
				ProductClass: o,
			}
		} else {
			rel.R.ProductClass = o
		}
	}
	return nil
}

// SetProductClassDTBOrderItems removes all previously related items of the
// dtb_product_class replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ProductClass's ProductClassDTBOrderItems accordingly.
// Replaces o.R.ProductClassDTBOrderItems with related.
// Sets related.R.ProductClass's ProductClassDTBOrderItems accordingly.
func (o *DTBProductClass) SetProductClassDTBOrderItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBOrderItem) error {
	query := "update `dtb_order_item` set `product_class_id` = null where `product_class_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ProductClassDTBOrderItems {
			queries.SetScanner(&rel.ProductClassID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ProductClass = nil
		}

		o.R.ProductClassDTBOrderItems = nil
	}
	return o.AddProductClassDTBOrderItems(ctx, exec, insert, related...)
}

// RemoveProductClassDTBOrderItems relationships from objects passed in.
// Removes related items from R.ProductClassDTBOrderItems (uses pointer comparison, removal does not keep order)
// Sets related.R.ProductClass.
func (o *DTBProductClass) RemoveProductClassDTBOrderItems(ctx context.Context, exec boil.ContextExecutor, related ...*DTBOrderItem) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ProductClassID, nil)
		if rel.R != nil {
			rel.R.ProductClass = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("product_class_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ProductClassDTBOrderItems {
			if rel != ri {
				continue
			}

			ln := len(o.R.ProductClassDTBOrderItems)
			if ln > 1 && i < ln-1 {
				o.R.ProductClassDTBOrderItems[i] = o.R.ProductClassDTBOrderItems[ln-1]
			}
			o.R.ProductClassDTBOrderItems = o.R.ProductClassDTBOrderItems[:ln-1]
			break
		}
	}

	return nil
}

// AddProductClassDTBProductStocks adds the given related objects to the existing relationships
// of the dtb_product_class, optionally inserting them as new records.
// Appends related to o.R.ProductClassDTBProductStocks.
// Sets related.R.ProductClass appropriately.
func (o *DTBProductClass) AddProductClassDTBProductStocks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductStock) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ProductClassID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_product_stock` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"product_class_id"}),
				strmangle.WhereClause("`", "`", 0, dtbProductStockPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ProductClassID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbProductClassR{
			ProductClassDTBProductStocks: related,
		}
	} else {
		o.R.ProductClassDTBProductStocks = append(o.R.ProductClassDTBProductStocks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbProductStockR{
				ProductClass: o,
			}
		} else {
			rel.R.ProductClass = o
		}
	}
	return nil
}

// SetProductClassDTBProductStocks removes all previously related items of the
// dtb_product_class replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ProductClass's ProductClassDTBProductStocks accordingly.
// Replaces o.R.ProductClassDTBProductStocks with related.
// Sets related.R.ProductClass's ProductClassDTBProductStocks accordingly.
func (o *DTBProductClass) SetProductClassDTBProductStocks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductStock) error {
	query := "update `dtb_product_stock` set `product_class_id` = null where `product_class_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ProductClassDTBProductStocks {
			queries.SetScanner(&rel.ProductClassID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ProductClass = nil
		}

		o.R.ProductClassDTBProductStocks = nil
	}
	return o.AddProductClassDTBProductStocks(ctx, exec, insert, related...)
}

// RemoveProductClassDTBProductStocks relationships from objects passed in.
// Removes related items from R.ProductClassDTBProductStocks (uses pointer comparison, removal does not keep order)
// Sets related.R.ProductClass.
func (o *DTBProductClass) RemoveProductClassDTBProductStocks(ctx context.Context, exec boil.ContextExecutor, related ...*DTBProductStock) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ProductClassID, nil)
		if rel.R != nil {
			rel.R.ProductClass = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("product_class_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ProductClassDTBProductStocks {
			if rel != ri {
				continue
			}

			ln := len(o.R.ProductClassDTBProductStocks)
			if ln > 1 && i < ln-1 {
				o.R.ProductClassDTBProductStocks[i] = o.R.ProductClassDTBProductStocks[ln-1]
			}
			o.R.ProductClassDTBProductStocks = o.R.ProductClassDTBProductStocks[:ln-1]
			break
		}
	}

	return nil
}

// AddProductClassDTBTaxRules adds the given related objects to the existing relationships
// of the dtb_product_class, optionally inserting them as new records.
// Appends related to o.R.ProductClassDTBTaxRules.
// Sets related.R.ProductClass appropriately.
func (o *DTBProductClass) AddProductClassDTBTaxRules(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBTaxRule) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ProductClassID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_tax_rule` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"product_class_id"}),
				strmangle.WhereClause("`", "`", 0, dtbTaxRulePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ProductClassID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbProductClassR{
			ProductClassDTBTaxRules: related,
		}
	} else {
		o.R.ProductClassDTBTaxRules = append(o.R.ProductClassDTBTaxRules, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbTaxRuleR{
				ProductClass: o,
			}
		} else {
			rel.R.ProductClass = o
		}
	}
	return nil
}

// SetProductClassDTBTaxRules removes all previously related items of the
// dtb_product_class replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ProductClass's ProductClassDTBTaxRules accordingly.
// Replaces o.R.ProductClassDTBTaxRules with related.
// Sets related.R.ProductClass's ProductClassDTBTaxRules accordingly.
func (o *DTBProductClass) SetProductClassDTBTaxRules(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBTaxRule) error {
	query := "update `dtb_tax_rule` set `product_class_id` = null where `product_class_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ProductClassDTBTaxRules {
			queries.SetScanner(&rel.ProductClassID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ProductClass = nil
		}

		o.R.ProductClassDTBTaxRules = nil
	}
	return o.AddProductClassDTBTaxRules(ctx, exec, insert, related...)
}

// RemoveProductClassDTBTaxRules relationships from objects passed in.
// Removes related items from R.ProductClassDTBTaxRules (uses pointer comparison, removal does not keep order)
// Sets related.R.ProductClass.
func (o *DTBProductClass) RemoveProductClassDTBTaxRules(ctx context.Context, exec boil.ContextExecutor, related ...*DTBTaxRule) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ProductClassID, nil)
		if rel.R != nil {
			rel.R.ProductClass = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("product_class_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ProductClassDTBTaxRules {
			if rel != ri {
				continue
			}

			ln := len(o.R.ProductClassDTBTaxRules)
			if ln > 1 && i < ln-1 {
				o.R.ProductClassDTBTaxRules[i] = o.R.ProductClassDTBTaxRules[ln-1]
			}
			o.R.ProductClassDTBTaxRules = o.R.ProductClassDTBTaxRules[:ln-1]
			break
		}
	}

	return nil
}

// DTBProductClasses retrieves all the records using an executor.
func DTBProductClasses(mods ...qm.QueryMod) dtbProductClassQuery {
	mods = append(mods, qm.From("`dtb_product_class`"))
	return dtbProductClassQuery{NewQuery(mods...)}
}

// FindDTBProductClass retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDTBProductClass(ctx context.Context, exec boil.ContextExecutor, iD uint, selectCols ...string) (*DTBProductClass, error) {
	dtbProductClassObj := &DTBProductClass{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `dtb_product_class` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, dtbProductClassObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from dtb_product_class")
	}

	return dtbProductClassObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DTBProductClass) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_product_class provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbProductClassColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dtbProductClassInsertCacheMut.RLock()
	cache, cached := dtbProductClassInsertCache[key]
	dtbProductClassInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dtbProductClassColumns,
			dtbProductClassColumnsWithDefault,
			dtbProductClassColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `dtb_product_class` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `dtb_product_class` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `dtb_product_class` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into dtb_product_class")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbProductClassMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_product_class")
	}

CacheNoHooks:
	if !cached {
		dtbProductClassInsertCacheMut.Lock()
		dtbProductClassInsertCache[key] = cache
		dtbProductClassInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DTBProductClass.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DTBProductClass) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	dtbProductClassUpdateCacheMut.RLock()
	cache, cached := dtbProductClassUpdateCache[key]
	dtbProductClassUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dtbProductClassColumns,
			dtbProductClassPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("model: unable to update dtb_product_class, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `dtb_product_class` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, append(wl, dtbProductClassPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update dtb_product_class row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by update for dtb_product_class")
	}

	if !cached {
		dtbProductClassUpdateCacheMut.Lock()
		dtbProductClassUpdateCache[key] = cache
		dtbProductClassUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q dtbProductClassQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all for dtb_product_class")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected for dtb_product_class")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DTBProductClassSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbProductClassPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `dtb_product_class` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbProductClassPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all in dtbProductClass slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected all in update all dtbProductClass")
	}
	return rowsAff, nil
}

var mySQLDTBProductClassUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DTBProductClass) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_product_class provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbProductClassColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDTBProductClassUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dtbProductClassUpsertCacheMut.RLock()
	cache, cached := dtbProductClassUpsertCache[key]
	dtbProductClassUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dtbProductClassColumns,
			dtbProductClassColumnsWithDefault,
			dtbProductClassColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			dtbProductClassColumns,
			dtbProductClassPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("model: unable to upsert dtb_product_class, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "dtb_product_class", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `dtb_product_class` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to upsert for dtb_product_class")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbProductClassMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dtbProductClassType, dtbProductClassMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "model: unable to retrieve unique values for dtb_product_class")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_product_class")
	}

CacheNoHooks:
	if !cached {
		dtbProductClassUpsertCacheMut.Lock()
		dtbProductClassUpsertCache[key] = cache
		dtbProductClassUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DTBProductClass record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DTBProductClass) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBProductClass provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dtbProductClassPrimaryKeyMapping)
	sql := "DELETE FROM `dtb_product_class` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete from dtb_product_class")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by delete for dtb_product_class")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q dtbProductClassQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("model: no dtbProductClassQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtb_product_class")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_product_class")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DTBProductClassSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBProductClass slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(dtbProductClassBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbProductClassPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `dtb_product_class` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbProductClassPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtbProductClass slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_product_class")
	}

	if len(dtbProductClassAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DTBProductClass) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDTBProductClass(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DTBProductClassSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DTBProductClassSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbProductClassPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `dtb_product_class`.* FROM `dtb_product_class` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbProductClassPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in DTBProductClassSlice")
	}

	*o = slice

	return nil
}

// DTBProductClassExists checks if the DTBProductClass row exists.
func DTBProductClassExists(ctx context.Context, exec boil.ContextExecutor, iD uint) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `dtb_product_class` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if dtb_product_class exists")
	}

	return exists, nil
}
