// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// DTBShipping is an object representing the database table.
type DTBShipping struct {
	ID                uint        `boil:"id" json:"id" toml:"id" yaml:"id"`
	OrderID           null.Uint   `boil:"order_id" json:"order_id,omitempty" toml:"order_id" yaml:"order_id,omitempty"`
	CountryID         null.Uint16 `boil:"country_id" json:"country_id,omitempty" toml:"country_id" yaml:"country_id,omitempty"`
	PrefID            null.Uint16 `boil:"pref_id" json:"pref_id,omitempty" toml:"pref_id" yaml:"pref_id,omitempty"`
	DeliveryID        null.Uint   `boil:"delivery_id" json:"delivery_id,omitempty" toml:"delivery_id" yaml:"delivery_id,omitempty"`
	CreatorID         null.Uint   `boil:"creator_id" json:"creator_id,omitempty" toml:"creator_id" yaml:"creator_id,omitempty"`
	Name01            string      `boil:"name01" json:"name01" toml:"name01" yaml:"name01"`
	Name02            string      `boil:"name02" json:"name02" toml:"name02" yaml:"name02"`
	Kana01            null.String `boil:"kana01" json:"kana01,omitempty" toml:"kana01" yaml:"kana01,omitempty"`
	Kana02            null.String `boil:"kana02" json:"kana02,omitempty" toml:"kana02" yaml:"kana02,omitempty"`
	CompanyName       null.String `boil:"company_name" json:"company_name,omitempty" toml:"company_name" yaml:"company_name,omitempty"`
	PhoneNumber       null.String `boil:"phone_number" json:"phone_number,omitempty" toml:"phone_number" yaml:"phone_number,omitempty"`
	PostalCode        null.String `boil:"postal_code" json:"postal_code,omitempty" toml:"postal_code" yaml:"postal_code,omitempty"`
	Addr01            null.String `boil:"addr01" json:"addr01,omitempty" toml:"addr01" yaml:"addr01,omitempty"`
	Addr02            null.String `boil:"addr02" json:"addr02,omitempty" toml:"addr02" yaml:"addr02,omitempty"`
	DeliveryName      null.String `boil:"delivery_name" json:"delivery_name,omitempty" toml:"delivery_name" yaml:"delivery_name,omitempty"`
	TimeID            null.Uint   `boil:"time_id" json:"time_id,omitempty" toml:"time_id" yaml:"time_id,omitempty"`
	DeliveryTime      null.String `boil:"delivery_time" json:"delivery_time,omitempty" toml:"delivery_time" yaml:"delivery_time,omitempty"`
	DeliveryDate      null.Time   `boil:"delivery_date" json:"delivery_date,omitempty" toml:"delivery_date" yaml:"delivery_date,omitempty"`
	ShippingDate      null.Time   `boil:"shipping_date" json:"shipping_date,omitempty" toml:"shipping_date" yaml:"shipping_date,omitempty"`
	TrackingNumber    null.String `boil:"tracking_number" json:"tracking_number,omitempty" toml:"tracking_number" yaml:"tracking_number,omitempty"`
	Note              null.String `boil:"note" json:"note,omitempty" toml:"note" yaml:"note,omitempty"`
	SortNo            null.Uint16 `boil:"sort_no" json:"sort_no,omitempty" toml:"sort_no" yaml:"sort_no,omitempty"`
	CreateDate        time.Time   `boil:"create_date" json:"create_date" toml:"create_date" yaml:"create_date"`
	UpdateDate        time.Time   `boil:"update_date" json:"update_date" toml:"update_date" yaml:"update_date"`
	MailSendDate      null.Time   `boil:"mail_send_date" json:"mail_send_date,omitempty" toml:"mail_send_date" yaml:"mail_send_date,omitempty"`
	DiscriminatorType string      `boil:"discriminator_type" json:"discriminator_type" toml:"discriminator_type" yaml:"discriminator_type"`

	R *dtbShippingR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dtbShippingL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DTBShippingColumns = struct {
	ID                string
	OrderID           string
	CountryID         string
	PrefID            string
	DeliveryID        string
	CreatorID         string
	Name01            string
	Name02            string
	Kana01            string
	Kana02            string
	CompanyName       string
	PhoneNumber       string
	PostalCode        string
	Addr01            string
	Addr02            string
	DeliveryName      string
	TimeID            string
	DeliveryTime      string
	DeliveryDate      string
	ShippingDate      string
	TrackingNumber    string
	Note              string
	SortNo            string
	CreateDate        string
	UpdateDate        string
	MailSendDate      string
	DiscriminatorType string
}{
	ID:                "id",
	OrderID:           "order_id",
	CountryID:         "country_id",
	PrefID:            "pref_id",
	DeliveryID:        "delivery_id",
	CreatorID:         "creator_id",
	Name01:            "name01",
	Name02:            "name02",
	Kana01:            "kana01",
	Kana02:            "kana02",
	CompanyName:       "company_name",
	PhoneNumber:       "phone_number",
	PostalCode:        "postal_code",
	Addr01:            "addr01",
	Addr02:            "addr02",
	DeliveryName:      "delivery_name",
	TimeID:            "time_id",
	DeliveryTime:      "delivery_time",
	DeliveryDate:      "delivery_date",
	ShippingDate:      "shipping_date",
	TrackingNumber:    "tracking_number",
	Note:              "note",
	SortNo:            "sort_no",
	CreateDate:        "create_date",
	UpdateDate:        "update_date",
	MailSendDate:      "mail_send_date",
	DiscriminatorType: "discriminator_type",
}

// Generated where

var DTBShippingWhere = struct {
	ID                whereHelperuint
	OrderID           whereHelpernull_Uint
	CountryID         whereHelpernull_Uint16
	PrefID            whereHelpernull_Uint16
	DeliveryID        whereHelpernull_Uint
	CreatorID         whereHelpernull_Uint
	Name01            whereHelperstring
	Name02            whereHelperstring
	Kana01            whereHelpernull_String
	Kana02            whereHelpernull_String
	CompanyName       whereHelpernull_String
	PhoneNumber       whereHelpernull_String
	PostalCode        whereHelpernull_String
	Addr01            whereHelpernull_String
	Addr02            whereHelpernull_String
	DeliveryName      whereHelpernull_String
	TimeID            whereHelpernull_Uint
	DeliveryTime      whereHelpernull_String
	DeliveryDate      whereHelpernull_Time
	ShippingDate      whereHelpernull_Time
	TrackingNumber    whereHelpernull_String
	Note              whereHelpernull_String
	SortNo            whereHelpernull_Uint16
	CreateDate        whereHelpertime_Time
	UpdateDate        whereHelpertime_Time
	MailSendDate      whereHelpernull_Time
	DiscriminatorType whereHelperstring
}{
	ID:                whereHelperuint{field: `id`},
	OrderID:           whereHelpernull_Uint{field: `order_id`},
	CountryID:         whereHelpernull_Uint16{field: `country_id`},
	PrefID:            whereHelpernull_Uint16{field: `pref_id`},
	DeliveryID:        whereHelpernull_Uint{field: `delivery_id`},
	CreatorID:         whereHelpernull_Uint{field: `creator_id`},
	Name01:            whereHelperstring{field: `name01`},
	Name02:            whereHelperstring{field: `name02`},
	Kana01:            whereHelpernull_String{field: `kana01`},
	Kana02:            whereHelpernull_String{field: `kana02`},
	CompanyName:       whereHelpernull_String{field: `company_name`},
	PhoneNumber:       whereHelpernull_String{field: `phone_number`},
	PostalCode:        whereHelpernull_String{field: `postal_code`},
	Addr01:            whereHelpernull_String{field: `addr01`},
	Addr02:            whereHelpernull_String{field: `addr02`},
	DeliveryName:      whereHelpernull_String{field: `delivery_name`},
	TimeID:            whereHelpernull_Uint{field: `time_id`},
	DeliveryTime:      whereHelpernull_String{field: `delivery_time`},
	DeliveryDate:      whereHelpernull_Time{field: `delivery_date`},
	ShippingDate:      whereHelpernull_Time{field: `shipping_date`},
	TrackingNumber:    whereHelpernull_String{field: `tracking_number`},
	Note:              whereHelpernull_String{field: `note`},
	SortNo:            whereHelpernull_Uint16{field: `sort_no`},
	CreateDate:        whereHelpertime_Time{field: `create_date`},
	UpdateDate:        whereHelpertime_Time{field: `update_date`},
	MailSendDate:      whereHelpernull_Time{field: `mail_send_date`},
	DiscriminatorType: whereHelperstring{field: `discriminator_type`},
}

// DTBShippingRels is where relationship names are stored.
var DTBShippingRels = struct {
	Delivery              string
	Creator               string
	Order                 string
	Pref                  string
	Country               string
	ShippingDTBOrderItems string
}{
	Delivery:              "Delivery",
	Creator:               "Creator",
	Order:                 "Order",
	Pref:                  "Pref",
	Country:               "Country",
	ShippingDTBOrderItems: "ShippingDTBOrderItems",
}

// dtbShippingR is where relationships are stored.
type dtbShippingR struct {
	Delivery              *DTBDelivery
	Creator               *DTBMember
	Order                 *DTBOrder
	Pref                  *MTBPref
	Country               *MTBCountry
	ShippingDTBOrderItems DTBOrderItemSlice
}

// NewStruct creates a new relationship struct
func (*dtbShippingR) NewStruct() *dtbShippingR {
	return &dtbShippingR{}
}

// dtbShippingL is where Load methods for each relationship are stored.
type dtbShippingL struct{}

var (
	dtbShippingColumns               = []string{"id", "order_id", "country_id", "pref_id", "delivery_id", "creator_id", "name01", "name02", "kana01", "kana02", "company_name", "phone_number", "postal_code", "addr01", "addr02", "delivery_name", "time_id", "delivery_time", "delivery_date", "shipping_date", "tracking_number", "note", "sort_no", "create_date", "update_date", "mail_send_date", "discriminator_type"}
	dtbShippingColumnsWithoutDefault = []string{"order_id", "country_id", "pref_id", "delivery_id", "creator_id", "name01", "name02", "kana01", "kana02", "company_name", "phone_number", "postal_code", "addr01", "addr02", "delivery_name", "time_id", "delivery_time", "delivery_date", "shipping_date", "tracking_number", "note", "sort_no", "create_date", "update_date", "mail_send_date", "discriminator_type"}
	dtbShippingColumnsWithDefault    = []string{"id"}
	dtbShippingPrimaryKeyColumns     = []string{"id"}
)

type (
	// DTBShippingSlice is an alias for a slice of pointers to DTBShipping.
	// This should generally be used opposed to []DTBShipping.
	DTBShippingSlice []*DTBShipping
	// DTBShippingHook is the signature for custom DTBShipping hook methods
	DTBShippingHook func(context.Context, boil.ContextExecutor, *DTBShipping) error

	dtbShippingQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dtbShippingType                 = reflect.TypeOf(&DTBShipping{})
	dtbShippingMapping              = queries.MakeStructMapping(dtbShippingType)
	dtbShippingPrimaryKeyMapping, _ = queries.BindMapping(dtbShippingType, dtbShippingMapping, dtbShippingPrimaryKeyColumns)
	dtbShippingInsertCacheMut       sync.RWMutex
	dtbShippingInsertCache          = make(map[string]insertCache)
	dtbShippingUpdateCacheMut       sync.RWMutex
	dtbShippingUpdateCache          = make(map[string]updateCache)
	dtbShippingUpsertCacheMut       sync.RWMutex
	dtbShippingUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var dtbShippingBeforeInsertHooks []DTBShippingHook
var dtbShippingBeforeUpdateHooks []DTBShippingHook
var dtbShippingBeforeDeleteHooks []DTBShippingHook
var dtbShippingBeforeUpsertHooks []DTBShippingHook

var dtbShippingAfterInsertHooks []DTBShippingHook
var dtbShippingAfterSelectHooks []DTBShippingHook
var dtbShippingAfterUpdateHooks []DTBShippingHook
var dtbShippingAfterDeleteHooks []DTBShippingHook
var dtbShippingAfterUpsertHooks []DTBShippingHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DTBShipping) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbShippingBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DTBShipping) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbShippingBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DTBShipping) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbShippingBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DTBShipping) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbShippingBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DTBShipping) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbShippingAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DTBShipping) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbShippingAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DTBShipping) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbShippingAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DTBShipping) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbShippingAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DTBShipping) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbShippingAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDTBShippingHook registers your hook function for all future operations.
func AddDTBShippingHook(hookPoint boil.HookPoint, dtbShippingHook DTBShippingHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		dtbShippingBeforeInsertHooks = append(dtbShippingBeforeInsertHooks, dtbShippingHook)
	case boil.BeforeUpdateHook:
		dtbShippingBeforeUpdateHooks = append(dtbShippingBeforeUpdateHooks, dtbShippingHook)
	case boil.BeforeDeleteHook:
		dtbShippingBeforeDeleteHooks = append(dtbShippingBeforeDeleteHooks, dtbShippingHook)
	case boil.BeforeUpsertHook:
		dtbShippingBeforeUpsertHooks = append(dtbShippingBeforeUpsertHooks, dtbShippingHook)
	case boil.AfterInsertHook:
		dtbShippingAfterInsertHooks = append(dtbShippingAfterInsertHooks, dtbShippingHook)
	case boil.AfterSelectHook:
		dtbShippingAfterSelectHooks = append(dtbShippingAfterSelectHooks, dtbShippingHook)
	case boil.AfterUpdateHook:
		dtbShippingAfterUpdateHooks = append(dtbShippingAfterUpdateHooks, dtbShippingHook)
	case boil.AfterDeleteHook:
		dtbShippingAfterDeleteHooks = append(dtbShippingAfterDeleteHooks, dtbShippingHook)
	case boil.AfterUpsertHook:
		dtbShippingAfterUpsertHooks = append(dtbShippingAfterUpsertHooks, dtbShippingHook)
	}
}

// One returns a single dtbShipping record from the query.
func (q dtbShippingQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DTBShipping, error) {
	o := &DTBShipping{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for dtb_shipping")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DTBShipping records from the query.
func (q dtbShippingQuery) All(ctx context.Context, exec boil.ContextExecutor) (DTBShippingSlice, error) {
	var o []*DTBShipping

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to DTBShipping slice")
	}

	if len(dtbShippingAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DTBShipping records in the query.
func (q dtbShippingQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count dtb_shipping rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dtbShippingQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if dtb_shipping exists")
	}

	return count > 0, nil
}

// Delivery pointed to by the foreign key.
func (o *DTBShipping) Delivery(mods ...qm.QueryMod) dtbDeliveryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.DeliveryID),
	}

	queryMods = append(queryMods, mods...)

	query := DTBDeliveries(queryMods...)
	queries.SetFrom(query.Query, "`dtb_delivery`")

	return query
}

// Creator pointed to by the foreign key.
func (o *DTBShipping) Creator(mods ...qm.QueryMod) dtbMemberQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.CreatorID),
	}

	queryMods = append(queryMods, mods...)

	query := DTBMembers(queryMods...)
	queries.SetFrom(query.Query, "`dtb_member`")

	return query
}

// Order pointed to by the foreign key.
func (o *DTBShipping) Order(mods ...qm.QueryMod) dtbOrderQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.OrderID),
	}

	queryMods = append(queryMods, mods...)

	query := DTBOrders(queryMods...)
	queries.SetFrom(query.Query, "`dtb_order`")

	return query
}

// Pref pointed to by the foreign key.
func (o *DTBShipping) Pref(mods ...qm.QueryMod) mtbPrefQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.PrefID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBPrefs(queryMods...)
	queries.SetFrom(query.Query, "`mtb_pref`")

	return query
}

// Country pointed to by the foreign key.
func (o *DTBShipping) Country(mods ...qm.QueryMod) mtbCountryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.CountryID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBCountries(queryMods...)
	queries.SetFrom(query.Query, "`mtb_country`")

	return query
}

// ShippingDTBOrderItems retrieves all the dtb_order_item's DTBOrderItems with an executor via shipping_id column.
func (o *DTBShipping) ShippingDTBOrderItems(mods ...qm.QueryMod) dtbOrderItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_order_item`.`shipping_id`=?", o.ID),
	)

	query := DTBOrderItems(queryMods...)
	queries.SetFrom(query.Query, "`dtb_order_item`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_order_item`.*"})
	}

	return query
}

// LoadDelivery allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbShippingL) LoadDelivery(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBShipping interface{}, mods queries.Applicator) error {
	var slice []*DTBShipping
	var object *DTBShipping

	if singular {
		object = maybeDTBShipping.(*DTBShipping)
	} else {
		slice = *maybeDTBShipping.(*[]*DTBShipping)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbShippingR{}
		}
		if !queries.IsNil(object.DeliveryID) {
			args = append(args, object.DeliveryID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbShippingR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliveryID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliveryID) {
				args = append(args, obj.DeliveryID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_delivery`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBDelivery")
	}

	var resultSlice []*DTBDelivery
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBDelivery")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_delivery")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_delivery")
	}

	if len(dtbShippingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Delivery = foreign
		if foreign.R == nil {
			foreign.R = &dtbDeliveryR{}
		}
		foreign.R.DeliveryDTBShippings = append(foreign.R.DeliveryDTBShippings, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliveryID, foreign.ID) {
				local.R.Delivery = foreign
				if foreign.R == nil {
					foreign.R = &dtbDeliveryR{}
				}
				foreign.R.DeliveryDTBShippings = append(foreign.R.DeliveryDTBShippings, local)
				break
			}
		}
	}

	return nil
}

// LoadCreator allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbShippingL) LoadCreator(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBShipping interface{}, mods queries.Applicator) error {
	var slice []*DTBShipping
	var object *DTBShipping

	if singular {
		object = maybeDTBShipping.(*DTBShipping)
	} else {
		slice = *maybeDTBShipping.(*[]*DTBShipping)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbShippingR{}
		}
		if !queries.IsNil(object.CreatorID) {
			args = append(args, object.CreatorID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbShippingR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CreatorID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CreatorID) {
				args = append(args, obj.CreatorID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_member`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBMember")
	}

	var resultSlice []*DTBMember
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBMember")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_member")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_member")
	}

	if len(dtbShippingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Creator = foreign
		if foreign.R == nil {
			foreign.R = &dtbMemberR{}
		}
		foreign.R.CreatorDTBShippings = append(foreign.R.CreatorDTBShippings, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CreatorID, foreign.ID) {
				local.R.Creator = foreign
				if foreign.R == nil {
					foreign.R = &dtbMemberR{}
				}
				foreign.R.CreatorDTBShippings = append(foreign.R.CreatorDTBShippings, local)
				break
			}
		}
	}

	return nil
}

// LoadOrder allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbShippingL) LoadOrder(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBShipping interface{}, mods queries.Applicator) error {
	var slice []*DTBShipping
	var object *DTBShipping

	if singular {
		object = maybeDTBShipping.(*DTBShipping)
	} else {
		slice = *maybeDTBShipping.(*[]*DTBShipping)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbShippingR{}
		}
		if !queries.IsNil(object.OrderID) {
			args = append(args, object.OrderID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbShippingR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.OrderID) {
				args = append(args, obj.OrderID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_order`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBOrder")
	}

	var resultSlice []*DTBOrder
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBOrder")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_order")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_order")
	}

	if len(dtbShippingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Order = foreign
		if foreign.R == nil {
			foreign.R = &dtbOrderR{}
		}
		foreign.R.OrderDTBShippings = append(foreign.R.OrderDTBShippings, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.OrderID, foreign.ID) {
				local.R.Order = foreign
				if foreign.R == nil {
					foreign.R = &dtbOrderR{}
				}
				foreign.R.OrderDTBShippings = append(foreign.R.OrderDTBShippings, local)
				break
			}
		}
	}

	return nil
}

// LoadPref allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbShippingL) LoadPref(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBShipping interface{}, mods queries.Applicator) error {
	var slice []*DTBShipping
	var object *DTBShipping

	if singular {
		object = maybeDTBShipping.(*DTBShipping)
	} else {
		slice = *maybeDTBShipping.(*[]*DTBShipping)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbShippingR{}
		}
		if !queries.IsNil(object.PrefID) {
			args = append(args, object.PrefID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbShippingR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PrefID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PrefID) {
				args = append(args, obj.PrefID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_pref`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBPref")
	}

	var resultSlice []*MTBPref
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBPref")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_pref")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_pref")
	}

	if len(dtbShippingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Pref = foreign
		if foreign.R == nil {
			foreign.R = &mtbPrefR{}
		}
		foreign.R.PrefDTBShippings = append(foreign.R.PrefDTBShippings, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PrefID, foreign.ID) {
				local.R.Pref = foreign
				if foreign.R == nil {
					foreign.R = &mtbPrefR{}
				}
				foreign.R.PrefDTBShippings = append(foreign.R.PrefDTBShippings, local)
				break
			}
		}
	}

	return nil
}

// LoadCountry allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbShippingL) LoadCountry(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBShipping interface{}, mods queries.Applicator) error {
	var slice []*DTBShipping
	var object *DTBShipping

	if singular {
		object = maybeDTBShipping.(*DTBShipping)
	} else {
		slice = *maybeDTBShipping.(*[]*DTBShipping)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbShippingR{}
		}
		if !queries.IsNil(object.CountryID) {
			args = append(args, object.CountryID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbShippingR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CountryID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CountryID) {
				args = append(args, obj.CountryID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_country`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBCountry")
	}

	var resultSlice []*MTBCountry
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBCountry")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_country")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_country")
	}

	if len(dtbShippingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Country = foreign
		if foreign.R == nil {
			foreign.R = &mtbCountryR{}
		}
		foreign.R.CountryDTBShippings = append(foreign.R.CountryDTBShippings, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CountryID, foreign.ID) {
				local.R.Country = foreign
				if foreign.R == nil {
					foreign.R = &mtbCountryR{}
				}
				foreign.R.CountryDTBShippings = append(foreign.R.CountryDTBShippings, local)
				break
			}
		}
	}

	return nil
}

// LoadShippingDTBOrderItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbShippingL) LoadShippingDTBOrderItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBShipping interface{}, mods queries.Applicator) error {
	var slice []*DTBShipping
	var object *DTBShipping

	if singular {
		object = maybeDTBShipping.(*DTBShipping)
	} else {
		slice = *maybeDTBShipping.(*[]*DTBShipping)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbShippingR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbShippingR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_order_item`), qm.WhereIn(`shipping_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_order_item")
	}

	var resultSlice []*DTBOrderItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_order_item")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_order_item")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_order_item")
	}

	if len(dtbOrderItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ShippingDTBOrderItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbOrderItemR{}
			}
			foreign.R.Shipping = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ShippingID) {
				local.R.ShippingDTBOrderItems = append(local.R.ShippingDTBOrderItems, foreign)
				if foreign.R == nil {
					foreign.R = &dtbOrderItemR{}
				}
				foreign.R.Shipping = local
				break
			}
		}
	}

	return nil
}

// SetDelivery of the dtbShipping to the related item.
// Sets o.R.Delivery to related.
// Adds o to related.R.DeliveryDTBShippings.
func (o *DTBShipping) SetDelivery(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBDelivery) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_shipping` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"delivery_id"}),
		strmangle.WhereClause("`", "`", 0, dtbShippingPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliveryID, related.ID)
	if o.R == nil {
		o.R = &dtbShippingR{
			Delivery: related,
		}
	} else {
		o.R.Delivery = related
	}

	if related.R == nil {
		related.R = &dtbDeliveryR{
			DeliveryDTBShippings: DTBShippingSlice{o},
		}
	} else {
		related.R.DeliveryDTBShippings = append(related.R.DeliveryDTBShippings, o)
	}

	return nil
}

// RemoveDelivery relationship.
// Sets o.R.Delivery to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBShipping) RemoveDelivery(ctx context.Context, exec boil.ContextExecutor, related *DTBDelivery) error {
	var err error

	queries.SetScanner(&o.DeliveryID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("delivery_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Delivery = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DeliveryDTBShippings {
		if queries.Equal(o.DeliveryID, ri.DeliveryID) {
			continue
		}

		ln := len(related.R.DeliveryDTBShippings)
		if ln > 1 && i < ln-1 {
			related.R.DeliveryDTBShippings[i] = related.R.DeliveryDTBShippings[ln-1]
		}
		related.R.DeliveryDTBShippings = related.R.DeliveryDTBShippings[:ln-1]
		break
	}
	return nil
}

// SetCreator of the dtbShipping to the related item.
// Sets o.R.Creator to related.
// Adds o to related.R.CreatorDTBShippings.
func (o *DTBShipping) SetCreator(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBMember) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_shipping` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
		strmangle.WhereClause("`", "`", 0, dtbShippingPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CreatorID, related.ID)
	if o.R == nil {
		o.R = &dtbShippingR{
			Creator: related,
		}
	} else {
		o.R.Creator = related
	}

	if related.R == nil {
		related.R = &dtbMemberR{
			CreatorDTBShippings: DTBShippingSlice{o},
		}
	} else {
		related.R.CreatorDTBShippings = append(related.R.CreatorDTBShippings, o)
	}

	return nil
}

// RemoveCreator relationship.
// Sets o.R.Creator to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBShipping) RemoveCreator(ctx context.Context, exec boil.ContextExecutor, related *DTBMember) error {
	var err error

	queries.SetScanner(&o.CreatorID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Creator = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CreatorDTBShippings {
		if queries.Equal(o.CreatorID, ri.CreatorID) {
			continue
		}

		ln := len(related.R.CreatorDTBShippings)
		if ln > 1 && i < ln-1 {
			related.R.CreatorDTBShippings[i] = related.R.CreatorDTBShippings[ln-1]
		}
		related.R.CreatorDTBShippings = related.R.CreatorDTBShippings[:ln-1]
		break
	}
	return nil
}

// SetOrder of the dtbShipping to the related item.
// Sets o.R.Order to related.
// Adds o to related.R.OrderDTBShippings.
func (o *DTBShipping) SetOrder(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBOrder) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_shipping` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"order_id"}),
		strmangle.WhereClause("`", "`", 0, dtbShippingPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.OrderID, related.ID)
	if o.R == nil {
		o.R = &dtbShippingR{
			Order: related,
		}
	} else {
		o.R.Order = related
	}

	if related.R == nil {
		related.R = &dtbOrderR{
			OrderDTBShippings: DTBShippingSlice{o},
		}
	} else {
		related.R.OrderDTBShippings = append(related.R.OrderDTBShippings, o)
	}

	return nil
}

// RemoveOrder relationship.
// Sets o.R.Order to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBShipping) RemoveOrder(ctx context.Context, exec boil.ContextExecutor, related *DTBOrder) error {
	var err error

	queries.SetScanner(&o.OrderID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("order_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Order = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.OrderDTBShippings {
		if queries.Equal(o.OrderID, ri.OrderID) {
			continue
		}

		ln := len(related.R.OrderDTBShippings)
		if ln > 1 && i < ln-1 {
			related.R.OrderDTBShippings[i] = related.R.OrderDTBShippings[ln-1]
		}
		related.R.OrderDTBShippings = related.R.OrderDTBShippings[:ln-1]
		break
	}
	return nil
}

// SetPref of the dtbShipping to the related item.
// Sets o.R.Pref to related.
// Adds o to related.R.PrefDTBShippings.
func (o *DTBShipping) SetPref(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBPref) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_shipping` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"pref_id"}),
		strmangle.WhereClause("`", "`", 0, dtbShippingPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PrefID, related.ID)
	if o.R == nil {
		o.R = &dtbShippingR{
			Pref: related,
		}
	} else {
		o.R.Pref = related
	}

	if related.R == nil {
		related.R = &mtbPrefR{
			PrefDTBShippings: DTBShippingSlice{o},
		}
	} else {
		related.R.PrefDTBShippings = append(related.R.PrefDTBShippings, o)
	}

	return nil
}

// RemovePref relationship.
// Sets o.R.Pref to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBShipping) RemovePref(ctx context.Context, exec boil.ContextExecutor, related *MTBPref) error {
	var err error

	queries.SetScanner(&o.PrefID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("pref_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Pref = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PrefDTBShippings {
		if queries.Equal(o.PrefID, ri.PrefID) {
			continue
		}

		ln := len(related.R.PrefDTBShippings)
		if ln > 1 && i < ln-1 {
			related.R.PrefDTBShippings[i] = related.R.PrefDTBShippings[ln-1]
		}
		related.R.PrefDTBShippings = related.R.PrefDTBShippings[:ln-1]
		break
	}
	return nil
}

// SetCountry of the dtbShipping to the related item.
// Sets o.R.Country to related.
// Adds o to related.R.CountryDTBShippings.
func (o *DTBShipping) SetCountry(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBCountry) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_shipping` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"country_id"}),
		strmangle.WhereClause("`", "`", 0, dtbShippingPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CountryID, related.ID)
	if o.R == nil {
		o.R = &dtbShippingR{
			Country: related,
		}
	} else {
		o.R.Country = related
	}

	if related.R == nil {
		related.R = &mtbCountryR{
			CountryDTBShippings: DTBShippingSlice{o},
		}
	} else {
		related.R.CountryDTBShippings = append(related.R.CountryDTBShippings, o)
	}

	return nil
}

// RemoveCountry relationship.
// Sets o.R.Country to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBShipping) RemoveCountry(ctx context.Context, exec boil.ContextExecutor, related *MTBCountry) error {
	var err error

	queries.SetScanner(&o.CountryID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("country_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Country = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CountryDTBShippings {
		if queries.Equal(o.CountryID, ri.CountryID) {
			continue
		}

		ln := len(related.R.CountryDTBShippings)
		if ln > 1 && i < ln-1 {
			related.R.CountryDTBShippings[i] = related.R.CountryDTBShippings[ln-1]
		}
		related.R.CountryDTBShippings = related.R.CountryDTBShippings[:ln-1]
		break
	}
	return nil
}

// AddShippingDTBOrderItems adds the given related objects to the existing relationships
// of the dtb_shipping, optionally inserting them as new records.
// Appends related to o.R.ShippingDTBOrderItems.
// Sets related.R.Shipping appropriately.
func (o *DTBShipping) AddShippingDTBOrderItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBOrderItem) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ShippingID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_order_item` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"shipping_id"}),
				strmangle.WhereClause("`", "`", 0, dtbOrderItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ShippingID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbShippingR{
			ShippingDTBOrderItems: related,
		}
	} else {
		o.R.ShippingDTBOrderItems = append(o.R.ShippingDTBOrderItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbOrderItemR{
				Shipping: o,
			}
		} else {
			rel.R.Shipping = o
		}
	}
	return nil
}

// SetShippingDTBOrderItems removes all previously related items of the
// dtb_shipping replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Shipping's ShippingDTBOrderItems accordingly.
// Replaces o.R.ShippingDTBOrderItems with related.
// Sets related.R.Shipping's ShippingDTBOrderItems accordingly.
func (o *DTBShipping) SetShippingDTBOrderItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBOrderItem) error {
	query := "update `dtb_order_item` set `shipping_id` = null where `shipping_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ShippingDTBOrderItems {
			queries.SetScanner(&rel.ShippingID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Shipping = nil
		}

		o.R.ShippingDTBOrderItems = nil
	}
	return o.AddShippingDTBOrderItems(ctx, exec, insert, related...)
}

// RemoveShippingDTBOrderItems relationships from objects passed in.
// Removes related items from R.ShippingDTBOrderItems (uses pointer comparison, removal does not keep order)
// Sets related.R.Shipping.
func (o *DTBShipping) RemoveShippingDTBOrderItems(ctx context.Context, exec boil.ContextExecutor, related ...*DTBOrderItem) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ShippingID, nil)
		if rel.R != nil {
			rel.R.Shipping = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("shipping_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ShippingDTBOrderItems {
			if rel != ri {
				continue
			}

			ln := len(o.R.ShippingDTBOrderItems)
			if ln > 1 && i < ln-1 {
				o.R.ShippingDTBOrderItems[i] = o.R.ShippingDTBOrderItems[ln-1]
			}
			o.R.ShippingDTBOrderItems = o.R.ShippingDTBOrderItems[:ln-1]
			break
		}
	}

	return nil
}

// DTBShippings retrieves all the records using an executor.
func DTBShippings(mods ...qm.QueryMod) dtbShippingQuery {
	mods = append(mods, qm.From("`dtb_shipping`"))
	return dtbShippingQuery{NewQuery(mods...)}
}

// FindDTBShipping retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDTBShipping(ctx context.Context, exec boil.ContextExecutor, iD uint, selectCols ...string) (*DTBShipping, error) {
	dtbShippingObj := &DTBShipping{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `dtb_shipping` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, dtbShippingObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from dtb_shipping")
	}

	return dtbShippingObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DTBShipping) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_shipping provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbShippingColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dtbShippingInsertCacheMut.RLock()
	cache, cached := dtbShippingInsertCache[key]
	dtbShippingInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dtbShippingColumns,
			dtbShippingColumnsWithDefault,
			dtbShippingColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dtbShippingType, dtbShippingMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dtbShippingType, dtbShippingMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `dtb_shipping` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `dtb_shipping` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `dtb_shipping` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dtbShippingPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into dtb_shipping")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbShippingMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_shipping")
	}

CacheNoHooks:
	if !cached {
		dtbShippingInsertCacheMut.Lock()
		dtbShippingInsertCache[key] = cache
		dtbShippingInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DTBShipping.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DTBShipping) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	dtbShippingUpdateCacheMut.RLock()
	cache, cached := dtbShippingUpdateCache[key]
	dtbShippingUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dtbShippingColumns,
			dtbShippingPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("model: unable to update dtb_shipping, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `dtb_shipping` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dtbShippingPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dtbShippingType, dtbShippingMapping, append(wl, dtbShippingPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update dtb_shipping row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by update for dtb_shipping")
	}

	if !cached {
		dtbShippingUpdateCacheMut.Lock()
		dtbShippingUpdateCache[key] = cache
		dtbShippingUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q dtbShippingQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all for dtb_shipping")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected for dtb_shipping")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DTBShippingSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbShippingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `dtb_shipping` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbShippingPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all in dtbShipping slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected all in update all dtbShipping")
	}
	return rowsAff, nil
}

var mySQLDTBShippingUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DTBShipping) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_shipping provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbShippingColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDTBShippingUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dtbShippingUpsertCacheMut.RLock()
	cache, cached := dtbShippingUpsertCache[key]
	dtbShippingUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dtbShippingColumns,
			dtbShippingColumnsWithDefault,
			dtbShippingColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			dtbShippingColumns,
			dtbShippingPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("model: unable to upsert dtb_shipping, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "dtb_shipping", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `dtb_shipping` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dtbShippingType, dtbShippingMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dtbShippingType, dtbShippingMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to upsert for dtb_shipping")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbShippingMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dtbShippingType, dtbShippingMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "model: unable to retrieve unique values for dtb_shipping")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_shipping")
	}

CacheNoHooks:
	if !cached {
		dtbShippingUpsertCacheMut.Lock()
		dtbShippingUpsertCache[key] = cache
		dtbShippingUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DTBShipping record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DTBShipping) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBShipping provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dtbShippingPrimaryKeyMapping)
	sql := "DELETE FROM `dtb_shipping` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete from dtb_shipping")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by delete for dtb_shipping")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q dtbShippingQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("model: no dtbShippingQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtb_shipping")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_shipping")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DTBShippingSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBShipping slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(dtbShippingBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbShippingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `dtb_shipping` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbShippingPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtbShipping slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_shipping")
	}

	if len(dtbShippingAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DTBShipping) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDTBShipping(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DTBShippingSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DTBShippingSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbShippingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `dtb_shipping`.* FROM `dtb_shipping` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbShippingPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in DTBShippingSlice")
	}

	*o = slice

	return nil
}

// DTBShippingExists checks if the DTBShipping row exists.
func DTBShippingExists(ctx context.Context, exec boil.ContextExecutor, iD uint) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `dtb_shipping` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if dtb_shipping exists")
	}

	return exists, nil
}
