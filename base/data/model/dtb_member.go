// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// DTBMember is an object representing the database table.
type DTBMember struct {
	ID                uint        `boil:"id" json:"id" toml:"id" yaml:"id"`
	WorkID            null.Uint16 `boil:"work_id" json:"work_id,omitempty" toml:"work_id" yaml:"work_id,omitempty"`
	AuthorityID       null.Uint16 `boil:"authority_id" json:"authority_id,omitempty" toml:"authority_id" yaml:"authority_id,omitempty"`
	CreatorID         null.Uint   `boil:"creator_id" json:"creator_id,omitempty" toml:"creator_id" yaml:"creator_id,omitempty"`
	Name              null.String `boil:"name" json:"name,omitempty" toml:"name" yaml:"name,omitempty"`
	Department        null.String `boil:"department" json:"department,omitempty" toml:"department" yaml:"department,omitempty"`
	LoginID           string      `boil:"login_id" json:"login_id" toml:"login_id" yaml:"login_id"`
	Password          string      `boil:"password" json:"password" toml:"password" yaml:"password"`
	Salt              null.String `boil:"salt" json:"salt,omitempty" toml:"salt" yaml:"salt,omitempty"`
	SortNo            uint16      `boil:"sort_no" json:"sort_no" toml:"sort_no" yaml:"sort_no"`
	CreateDate        time.Time   `boil:"create_date" json:"create_date" toml:"create_date" yaml:"create_date"`
	UpdateDate        time.Time   `boil:"update_date" json:"update_date" toml:"update_date" yaml:"update_date"`
	LoginDate         null.Time   `boil:"login_date" json:"login_date,omitempty" toml:"login_date" yaml:"login_date,omitempty"`
	DiscriminatorType string      `boil:"discriminator_type" json:"discriminator_type" toml:"discriminator_type" yaml:"discriminator_type"`

	R *dtbMemberR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dtbMemberL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DTBMemberColumns = struct {
	ID                string
	WorkID            string
	AuthorityID       string
	CreatorID         string
	Name              string
	Department        string
	LoginID           string
	Password          string
	Salt              string
	SortNo            string
	CreateDate        string
	UpdateDate        string
	LoginDate         string
	DiscriminatorType string
}{
	ID:                "id",
	WorkID:            "work_id",
	AuthorityID:       "authority_id",
	CreatorID:         "creator_id",
	Name:              "name",
	Department:        "department",
	LoginID:           "login_id",
	Password:          "password",
	Salt:              "salt",
	SortNo:            "sort_no",
	CreateDate:        "create_date",
	UpdateDate:        "update_date",
	LoginDate:         "login_date",
	DiscriminatorType: "discriminator_type",
}

// Generated where

var DTBMemberWhere = struct {
	ID                whereHelperuint
	WorkID            whereHelpernull_Uint16
	AuthorityID       whereHelpernull_Uint16
	CreatorID         whereHelpernull_Uint
	Name              whereHelpernull_String
	Department        whereHelpernull_String
	LoginID           whereHelperstring
	Password          whereHelperstring
	Salt              whereHelpernull_String
	SortNo            whereHelperuint16
	CreateDate        whereHelpertime_Time
	UpdateDate        whereHelpertime_Time
	LoginDate         whereHelpernull_Time
	DiscriminatorType whereHelperstring
}{
	ID:                whereHelperuint{field: `id`},
	WorkID:            whereHelpernull_Uint16{field: `work_id`},
	AuthorityID:       whereHelpernull_Uint16{field: `authority_id`},
	CreatorID:         whereHelpernull_Uint{field: `creator_id`},
	Name:              whereHelpernull_String{field: `name`},
	Department:        whereHelpernull_String{field: `department`},
	LoginID:           whereHelperstring{field: `login_id`},
	Password:          whereHelperstring{field: `password`},
	Salt:              whereHelpernull_String{field: `salt`},
	SortNo:            whereHelperuint16{field: `sort_no`},
	CreateDate:        whereHelpertime_Time{field: `create_date`},
	UpdateDate:        whereHelpertime_Time{field: `update_date`},
	LoginDate:         whereHelpernull_Time{field: `login_date`},
	DiscriminatorType: whereHelperstring{field: `discriminator_type`},
}

// DTBMemberRels is where relationship names are stored.
var DTBMemberRels = struct {
	Creator                   string
	Authority                 string
	Work                      string
	CreatorDTBAuthorityRoles  string
	CreatorDTBCategories      string
	CreatorDTBClassCategories string
	CreatorDTBClassNames      string
	CreatorDTBCSVS            string
	CreatorDTBDeliveries      string
	CreatorDTBMailHistories   string
	CreatorDTBMailTemplates   string
	CreatorDTBMembers         string
	CreatorDTBNews            string
	CreatorDTBPayments        string
	CreatorDTBProducts        string
	CreatorDTBProductClasses  string
	CreatorDTBProductImages   string
	CreatorDTBProductStocks   string
	CreatorDTBProductTags     string
	CreatorDTBShippings       string
	CreatorDTBTaxRules        string
}{
	Creator:                   "Creator",
	Authority:                 "Authority",
	Work:                      "Work",
	CreatorDTBAuthorityRoles:  "CreatorDTBAuthorityRoles",
	CreatorDTBCategories:      "CreatorDTBCategories",
	CreatorDTBClassCategories: "CreatorDTBClassCategories",
	CreatorDTBClassNames:      "CreatorDTBClassNames",
	CreatorDTBCSVS:            "CreatorDTBCSVS",
	CreatorDTBDeliveries:      "CreatorDTBDeliveries",
	CreatorDTBMailHistories:   "CreatorDTBMailHistories",
	CreatorDTBMailTemplates:   "CreatorDTBMailTemplates",
	CreatorDTBMembers:         "CreatorDTBMembers",
	CreatorDTBNews:            "CreatorDTBNews",
	CreatorDTBPayments:        "CreatorDTBPayments",
	CreatorDTBProducts:        "CreatorDTBProducts",
	CreatorDTBProductClasses:  "CreatorDTBProductClasses",
	CreatorDTBProductImages:   "CreatorDTBProductImages",
	CreatorDTBProductStocks:   "CreatorDTBProductStocks",
	CreatorDTBProductTags:     "CreatorDTBProductTags",
	CreatorDTBShippings:       "CreatorDTBShippings",
	CreatorDTBTaxRules:        "CreatorDTBTaxRules",
}

// dtbMemberR is where relationships are stored.
type dtbMemberR struct {
	Creator                   *DTBMember
	Authority                 *MTBAuthority
	Work                      *MTBWork
	CreatorDTBAuthorityRoles  DTBAuthorityRoleSlice
	CreatorDTBCategories      DTBCategorySlice
	CreatorDTBClassCategories DTBClassCategorySlice
	CreatorDTBClassNames      DTBClassNameSlice
	CreatorDTBCSVS            DTBCSVSlice
	CreatorDTBDeliveries      DTBDeliverySlice
	CreatorDTBMailHistories   DTBMailHistorySlice
	CreatorDTBMailTemplates   DTBMailTemplateSlice
	CreatorDTBMembers         DTBMemberSlice
	CreatorDTBNews            DTBNewsSlice
	CreatorDTBPayments        DTBPaymentSlice
	CreatorDTBProducts        DTBProductSlice
	CreatorDTBProductClasses  DTBProductClassSlice
	CreatorDTBProductImages   DTBProductImageSlice
	CreatorDTBProductStocks   DTBProductStockSlice
	CreatorDTBProductTags     DTBProductTagSlice
	CreatorDTBShippings       DTBShippingSlice
	CreatorDTBTaxRules        DTBTaxRuleSlice
}

// NewStruct creates a new relationship struct
func (*dtbMemberR) NewStruct() *dtbMemberR {
	return &dtbMemberR{}
}

// dtbMemberL is where Load methods for each relationship are stored.
type dtbMemberL struct{}

var (
	dtbMemberColumns               = []string{"id", "work_id", "authority_id", "creator_id", "name", "department", "login_id", "password", "salt", "sort_no", "create_date", "update_date", "login_date", "discriminator_type"}
	dtbMemberColumnsWithoutDefault = []string{"work_id", "authority_id", "creator_id", "name", "department", "login_id", "password", "salt", "sort_no", "create_date", "update_date", "login_date", "discriminator_type"}
	dtbMemberColumnsWithDefault    = []string{"id"}
	dtbMemberPrimaryKeyColumns     = []string{"id"}
)

type (
	// DTBMemberSlice is an alias for a slice of pointers to DTBMember.
	// This should generally be used opposed to []DTBMember.
	DTBMemberSlice []*DTBMember
	// DTBMemberHook is the signature for custom DTBMember hook methods
	DTBMemberHook func(context.Context, boil.ContextExecutor, *DTBMember) error

	dtbMemberQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dtbMemberType                 = reflect.TypeOf(&DTBMember{})
	dtbMemberMapping              = queries.MakeStructMapping(dtbMemberType)
	dtbMemberPrimaryKeyMapping, _ = queries.BindMapping(dtbMemberType, dtbMemberMapping, dtbMemberPrimaryKeyColumns)
	dtbMemberInsertCacheMut       sync.RWMutex
	dtbMemberInsertCache          = make(map[string]insertCache)
	dtbMemberUpdateCacheMut       sync.RWMutex
	dtbMemberUpdateCache          = make(map[string]updateCache)
	dtbMemberUpsertCacheMut       sync.RWMutex
	dtbMemberUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var dtbMemberBeforeInsertHooks []DTBMemberHook
var dtbMemberBeforeUpdateHooks []DTBMemberHook
var dtbMemberBeforeDeleteHooks []DTBMemberHook
var dtbMemberBeforeUpsertHooks []DTBMemberHook

var dtbMemberAfterInsertHooks []DTBMemberHook
var dtbMemberAfterSelectHooks []DTBMemberHook
var dtbMemberAfterUpdateHooks []DTBMemberHook
var dtbMemberAfterDeleteHooks []DTBMemberHook
var dtbMemberAfterUpsertHooks []DTBMemberHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DTBMember) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbMemberBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DTBMember) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbMemberBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DTBMember) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbMemberBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DTBMember) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbMemberBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DTBMember) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbMemberAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DTBMember) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbMemberAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DTBMember) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbMemberAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DTBMember) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbMemberAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DTBMember) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dtbMemberAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDTBMemberHook registers your hook function for all future operations.
func AddDTBMemberHook(hookPoint boil.HookPoint, dtbMemberHook DTBMemberHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		dtbMemberBeforeInsertHooks = append(dtbMemberBeforeInsertHooks, dtbMemberHook)
	case boil.BeforeUpdateHook:
		dtbMemberBeforeUpdateHooks = append(dtbMemberBeforeUpdateHooks, dtbMemberHook)
	case boil.BeforeDeleteHook:
		dtbMemberBeforeDeleteHooks = append(dtbMemberBeforeDeleteHooks, dtbMemberHook)
	case boil.BeforeUpsertHook:
		dtbMemberBeforeUpsertHooks = append(dtbMemberBeforeUpsertHooks, dtbMemberHook)
	case boil.AfterInsertHook:
		dtbMemberAfterInsertHooks = append(dtbMemberAfterInsertHooks, dtbMemberHook)
	case boil.AfterSelectHook:
		dtbMemberAfterSelectHooks = append(dtbMemberAfterSelectHooks, dtbMemberHook)
	case boil.AfterUpdateHook:
		dtbMemberAfterUpdateHooks = append(dtbMemberAfterUpdateHooks, dtbMemberHook)
	case boil.AfterDeleteHook:
		dtbMemberAfterDeleteHooks = append(dtbMemberAfterDeleteHooks, dtbMemberHook)
	case boil.AfterUpsertHook:
		dtbMemberAfterUpsertHooks = append(dtbMemberAfterUpsertHooks, dtbMemberHook)
	}
}

// One returns a single dtbMember record from the query.
func (q dtbMemberQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DTBMember, error) {
	o := &DTBMember{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for dtb_member")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DTBMember records from the query.
func (q dtbMemberQuery) All(ctx context.Context, exec boil.ContextExecutor) (DTBMemberSlice, error) {
	var o []*DTBMember

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to DTBMember slice")
	}

	if len(dtbMemberAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DTBMember records in the query.
func (q dtbMemberQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count dtb_member rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dtbMemberQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if dtb_member exists")
	}

	return count > 0, nil
}

// Creator pointed to by the foreign key.
func (o *DTBMember) Creator(mods ...qm.QueryMod) dtbMemberQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.CreatorID),
	}

	queryMods = append(queryMods, mods...)

	query := DTBMembers(queryMods...)
	queries.SetFrom(query.Query, "`dtb_member`")

	return query
}

// Authority pointed to by the foreign key.
func (o *DTBMember) Authority(mods ...qm.QueryMod) mtbAuthorityQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.AuthorityID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBAuthorities(queryMods...)
	queries.SetFrom(query.Query, "`mtb_authority`")

	return query
}

// Work pointed to by the foreign key.
func (o *DTBMember) Work(mods ...qm.QueryMod) mtbWorkQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.WorkID),
	}

	queryMods = append(queryMods, mods...)

	query := MTBWorks(queryMods...)
	queries.SetFrom(query.Query, "`mtb_work`")

	return query
}

// CreatorDTBAuthorityRoles retrieves all the dtb_authority_role's DTBAuthorityRoles with an executor via creator_id column.
func (o *DTBMember) CreatorDTBAuthorityRoles(mods ...qm.QueryMod) dtbAuthorityRoleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_authority_role`.`creator_id`=?", o.ID),
	)

	query := DTBAuthorityRoles(queryMods...)
	queries.SetFrom(query.Query, "`dtb_authority_role`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_authority_role`.*"})
	}

	return query
}

// CreatorDTBCategories retrieves all the dtb_category's DTBCategories with an executor via creator_id column.
func (o *DTBMember) CreatorDTBCategories(mods ...qm.QueryMod) dtbCategoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_category`.`creator_id`=?", o.ID),
	)

	query := DTBCategories(queryMods...)
	queries.SetFrom(query.Query, "`dtb_category`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_category`.*"})
	}

	return query
}

// CreatorDTBClassCategories retrieves all the dtb_class_category's DTBClassCategories with an executor via creator_id column.
func (o *DTBMember) CreatorDTBClassCategories(mods ...qm.QueryMod) dtbClassCategoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_class_category`.`creator_id`=?", o.ID),
	)

	query := DTBClassCategories(queryMods...)
	queries.SetFrom(query.Query, "`dtb_class_category`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_class_category`.*"})
	}

	return query
}

// CreatorDTBClassNames retrieves all the dtb_class_name's DTBClassNames with an executor via creator_id column.
func (o *DTBMember) CreatorDTBClassNames(mods ...qm.QueryMod) dtbClassNameQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_class_name`.`creator_id`=?", o.ID),
	)

	query := DTBClassNames(queryMods...)
	queries.SetFrom(query.Query, "`dtb_class_name`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_class_name`.*"})
	}

	return query
}

// CreatorDTBCSVS retrieves all the dtb_csv's DTBCSVS with an executor via creator_id column.
func (o *DTBMember) CreatorDTBCSVS(mods ...qm.QueryMod) dtbCSVQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_csv`.`creator_id`=?", o.ID),
	)

	query := DTBCSVS(queryMods...)
	queries.SetFrom(query.Query, "`dtb_csv`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_csv`.*"})
	}

	return query
}

// CreatorDTBDeliveries retrieves all the dtb_delivery's DTBDeliveries with an executor via creator_id column.
func (o *DTBMember) CreatorDTBDeliveries(mods ...qm.QueryMod) dtbDeliveryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_delivery`.`creator_id`=?", o.ID),
	)

	query := DTBDeliveries(queryMods...)
	queries.SetFrom(query.Query, "`dtb_delivery`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_delivery`.*"})
	}

	return query
}

// CreatorDTBMailHistories retrieves all the dtb_mail_history's DTBMailHistories with an executor via creator_id column.
func (o *DTBMember) CreatorDTBMailHistories(mods ...qm.QueryMod) dtbMailHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_mail_history`.`creator_id`=?", o.ID),
	)

	query := DTBMailHistories(queryMods...)
	queries.SetFrom(query.Query, "`dtb_mail_history`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_mail_history`.*"})
	}

	return query
}

// CreatorDTBMailTemplates retrieves all the dtb_mail_template's DTBMailTemplates with an executor via creator_id column.
func (o *DTBMember) CreatorDTBMailTemplates(mods ...qm.QueryMod) dtbMailTemplateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_mail_template`.`creator_id`=?", o.ID),
	)

	query := DTBMailTemplates(queryMods...)
	queries.SetFrom(query.Query, "`dtb_mail_template`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_mail_template`.*"})
	}

	return query
}

// CreatorDTBMembers retrieves all the dtb_member's DTBMembers with an executor via creator_id column.
func (o *DTBMember) CreatorDTBMembers(mods ...qm.QueryMod) dtbMemberQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_member`.`creator_id`=?", o.ID),
	)

	query := DTBMembers(queryMods...)
	queries.SetFrom(query.Query, "`dtb_member`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_member`.*"})
	}

	return query
}

// CreatorDTBNews retrieves all the dtb_news's DTBNews with an executor via creator_id column.
func (o *DTBMember) CreatorDTBNews(mods ...qm.QueryMod) dtbNewsQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_news`.`creator_id`=?", o.ID),
	)

	query := DTBNews(queryMods...)
	queries.SetFrom(query.Query, "`dtb_news`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_news`.*"})
	}

	return query
}

// CreatorDTBPayments retrieves all the dtb_payment's DTBPayments with an executor via creator_id column.
func (o *DTBMember) CreatorDTBPayments(mods ...qm.QueryMod) dtbPaymentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_payment`.`creator_id`=?", o.ID),
	)

	query := DTBPayments(queryMods...)
	queries.SetFrom(query.Query, "`dtb_payment`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_payment`.*"})
	}

	return query
}

// CreatorDTBProducts retrieves all the dtb_product's DTBProducts with an executor via creator_id column.
func (o *DTBMember) CreatorDTBProducts(mods ...qm.QueryMod) dtbProductQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_product`.`creator_id`=?", o.ID),
	)

	query := DTBProducts(queryMods...)
	queries.SetFrom(query.Query, "`dtb_product`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_product`.*"})
	}

	return query
}

// CreatorDTBProductClasses retrieves all the dtb_product_class's DTBProductClasses with an executor via creator_id column.
func (o *DTBMember) CreatorDTBProductClasses(mods ...qm.QueryMod) dtbProductClassQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_product_class`.`creator_id`=?", o.ID),
	)

	query := DTBProductClasses(queryMods...)
	queries.SetFrom(query.Query, "`dtb_product_class`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_product_class`.*"})
	}

	return query
}

// CreatorDTBProductImages retrieves all the dtb_product_image's DTBProductImages with an executor via creator_id column.
func (o *DTBMember) CreatorDTBProductImages(mods ...qm.QueryMod) dtbProductImageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_product_image`.`creator_id`=?", o.ID),
	)

	query := DTBProductImages(queryMods...)
	queries.SetFrom(query.Query, "`dtb_product_image`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_product_image`.*"})
	}

	return query
}

// CreatorDTBProductStocks retrieves all the dtb_product_stock's DTBProductStocks with an executor via creator_id column.
func (o *DTBMember) CreatorDTBProductStocks(mods ...qm.QueryMod) dtbProductStockQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_product_stock`.`creator_id`=?", o.ID),
	)

	query := DTBProductStocks(queryMods...)
	queries.SetFrom(query.Query, "`dtb_product_stock`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_product_stock`.*"})
	}

	return query
}

// CreatorDTBProductTags retrieves all the dtb_product_tag's DTBProductTags with an executor via creator_id column.
func (o *DTBMember) CreatorDTBProductTags(mods ...qm.QueryMod) dtbProductTagQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_product_tag`.`creator_id`=?", o.ID),
	)

	query := DTBProductTags(queryMods...)
	queries.SetFrom(query.Query, "`dtb_product_tag`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_product_tag`.*"})
	}

	return query
}

// CreatorDTBShippings retrieves all the dtb_shipping's DTBShippings with an executor via creator_id column.
func (o *DTBMember) CreatorDTBShippings(mods ...qm.QueryMod) dtbShippingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_shipping`.`creator_id`=?", o.ID),
	)

	query := DTBShippings(queryMods...)
	queries.SetFrom(query.Query, "`dtb_shipping`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_shipping`.*"})
	}

	return query
}

// CreatorDTBTaxRules retrieves all the dtb_tax_rule's DTBTaxRules with an executor via creator_id column.
func (o *DTBMember) CreatorDTBTaxRules(mods ...qm.QueryMod) dtbTaxRuleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`dtb_tax_rule`.`creator_id`=?", o.ID),
	)

	query := DTBTaxRules(queryMods...)
	queries.SetFrom(query.Query, "`dtb_tax_rule`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`dtb_tax_rule`.*"})
	}

	return query
}

// LoadCreator allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbMemberL) LoadCreator(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		if !queries.IsNil(object.CreatorID) {
			args = append(args, object.CreatorID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CreatorID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CreatorID) {
				args = append(args, obj.CreatorID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_member`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DTBMember")
	}

	var resultSlice []*DTBMember
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DTBMember")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dtb_member")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_member")
	}

	if len(dtbMemberAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Creator = foreign
		if foreign.R == nil {
			foreign.R = &dtbMemberR{}
		}
		foreign.R.CreatorDTBMembers = append(foreign.R.CreatorDTBMembers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CreatorID, foreign.ID) {
				local.R.Creator = foreign
				if foreign.R == nil {
					foreign.R = &dtbMemberR{}
				}
				foreign.R.CreatorDTBMembers = append(foreign.R.CreatorDTBMembers, local)
				break
			}
		}
	}

	return nil
}

// LoadAuthority allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbMemberL) LoadAuthority(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		if !queries.IsNil(object.AuthorityID) {
			args = append(args, object.AuthorityID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AuthorityID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AuthorityID) {
				args = append(args, obj.AuthorityID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_authority`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBAuthority")
	}

	var resultSlice []*MTBAuthority
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBAuthority")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_authority")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_authority")
	}

	if len(dtbMemberAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Authority = foreign
		if foreign.R == nil {
			foreign.R = &mtbAuthorityR{}
		}
		foreign.R.AuthorityDTBMembers = append(foreign.R.AuthorityDTBMembers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AuthorityID, foreign.ID) {
				local.R.Authority = foreign
				if foreign.R == nil {
					foreign.R = &mtbAuthorityR{}
				}
				foreign.R.AuthorityDTBMembers = append(foreign.R.AuthorityDTBMembers, local)
				break
			}
		}
	}

	return nil
}

// LoadWork allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dtbMemberL) LoadWork(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		if !queries.IsNil(object.WorkID) {
			args = append(args, object.WorkID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.WorkID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.WorkID) {
				args = append(args, obj.WorkID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`mtb_work`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MTBWork")
	}

	var resultSlice []*MTBWork
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MTBWork")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for mtb_work")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mtb_work")
	}

	if len(dtbMemberAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Work = foreign
		if foreign.R == nil {
			foreign.R = &mtbWorkR{}
		}
		foreign.R.WorkDTBMembers = append(foreign.R.WorkDTBMembers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.WorkID, foreign.ID) {
				local.R.Work = foreign
				if foreign.R == nil {
					foreign.R = &mtbWorkR{}
				}
				foreign.R.WorkDTBMembers = append(foreign.R.WorkDTBMembers, local)
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBAuthorityRoles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBAuthorityRoles(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_authority_role`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_authority_role")
	}

	var resultSlice []*DTBAuthorityRole
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_authority_role")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_authority_role")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_authority_role")
	}

	if len(dtbAuthorityRoleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBAuthorityRoles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbAuthorityRoleR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBAuthorityRoles = append(local.R.CreatorDTBAuthorityRoles, foreign)
				if foreign.R == nil {
					foreign.R = &dtbAuthorityRoleR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBCategories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBCategories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_category`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_category")
	}

	var resultSlice []*DTBCategory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_category")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_category")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_category")
	}

	if len(dtbCategoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBCategories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbCategoryR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBCategories = append(local.R.CreatorDTBCategories, foreign)
				if foreign.R == nil {
					foreign.R = &dtbCategoryR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBClassCategories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBClassCategories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_class_category`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_class_category")
	}

	var resultSlice []*DTBClassCategory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_class_category")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_class_category")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_class_category")
	}

	if len(dtbClassCategoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBClassCategories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbClassCategoryR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBClassCategories = append(local.R.CreatorDTBClassCategories, foreign)
				if foreign.R == nil {
					foreign.R = &dtbClassCategoryR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBClassNames allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBClassNames(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_class_name`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_class_name")
	}

	var resultSlice []*DTBClassName
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_class_name")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_class_name")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_class_name")
	}

	if len(dtbClassNameAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBClassNames = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbClassNameR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBClassNames = append(local.R.CreatorDTBClassNames, foreign)
				if foreign.R == nil {
					foreign.R = &dtbClassNameR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBCSVS allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBCSVS(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_csv`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_csv")
	}

	var resultSlice []*DTBCSV
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_csv")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_csv")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_csv")
	}

	if len(dtbCSVAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBCSVS = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbCSVR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBCSVS = append(local.R.CreatorDTBCSVS, foreign)
				if foreign.R == nil {
					foreign.R = &dtbCSVR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBDeliveries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBDeliveries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_delivery`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_delivery")
	}

	var resultSlice []*DTBDelivery
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_delivery")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_delivery")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_delivery")
	}

	if len(dtbDeliveryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBDeliveries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbDeliveryR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBDeliveries = append(local.R.CreatorDTBDeliveries, foreign)
				if foreign.R == nil {
					foreign.R = &dtbDeliveryR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBMailHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBMailHistories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_mail_history`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_mail_history")
	}

	var resultSlice []*DTBMailHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_mail_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_mail_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_mail_history")
	}

	if len(dtbMailHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBMailHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbMailHistoryR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBMailHistories = append(local.R.CreatorDTBMailHistories, foreign)
				if foreign.R == nil {
					foreign.R = &dtbMailHistoryR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBMailTemplates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBMailTemplates(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_mail_template`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_mail_template")
	}

	var resultSlice []*DTBMailTemplate
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_mail_template")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_mail_template")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_mail_template")
	}

	if len(dtbMailTemplateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBMailTemplates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbMailTemplateR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBMailTemplates = append(local.R.CreatorDTBMailTemplates, foreign)
				if foreign.R == nil {
					foreign.R = &dtbMailTemplateR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBMembers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBMembers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_member`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_member")
	}

	var resultSlice []*DTBMember
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_member")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_member")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_member")
	}

	if len(dtbMemberAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBMembers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbMemberR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBMembers = append(local.R.CreatorDTBMembers, foreign)
				if foreign.R == nil {
					foreign.R = &dtbMemberR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBNews allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBNews(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_news`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_news")
	}

	var resultSlice []*DTBNews
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_news")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_news")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_news")
	}

	if len(dtbNewsAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBNews = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbNewsR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBNews = append(local.R.CreatorDTBNews, foreign)
				if foreign.R == nil {
					foreign.R = &dtbNewsR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBPayments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBPayments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_payment`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_payment")
	}

	var resultSlice []*DTBPayment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_payment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_payment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_payment")
	}

	if len(dtbPaymentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBPayments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbPaymentR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBPayments = append(local.R.CreatorDTBPayments, foreign)
				if foreign.R == nil {
					foreign.R = &dtbPaymentR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBProducts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBProducts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_product`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_product")
	}

	var resultSlice []*DTBProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_product")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_product")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_product")
	}

	if len(dtbProductAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBProducts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbProductR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBProducts = append(local.R.CreatorDTBProducts, foreign)
				if foreign.R == nil {
					foreign.R = &dtbProductR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBProductClasses allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBProductClasses(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_product_class`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_product_class")
	}

	var resultSlice []*DTBProductClass
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_product_class")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_product_class")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_product_class")
	}

	if len(dtbProductClassAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBProductClasses = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbProductClassR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBProductClasses = append(local.R.CreatorDTBProductClasses, foreign)
				if foreign.R == nil {
					foreign.R = &dtbProductClassR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBProductImages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBProductImages(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_product_image`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_product_image")
	}

	var resultSlice []*DTBProductImage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_product_image")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_product_image")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_product_image")
	}

	if len(dtbProductImageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBProductImages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbProductImageR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBProductImages = append(local.R.CreatorDTBProductImages, foreign)
				if foreign.R == nil {
					foreign.R = &dtbProductImageR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBProductStocks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBProductStocks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_product_stock`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_product_stock")
	}

	var resultSlice []*DTBProductStock
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_product_stock")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_product_stock")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_product_stock")
	}

	if len(dtbProductStockAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBProductStocks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbProductStockR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBProductStocks = append(local.R.CreatorDTBProductStocks, foreign)
				if foreign.R == nil {
					foreign.R = &dtbProductStockR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBProductTags allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBProductTags(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_product_tag`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_product_tag")
	}

	var resultSlice []*DTBProductTag
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_product_tag")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_product_tag")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_product_tag")
	}

	if len(dtbProductTagAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBProductTags = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbProductTagR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBProductTags = append(local.R.CreatorDTBProductTags, foreign)
				if foreign.R == nil {
					foreign.R = &dtbProductTagR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBShippings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBShippings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_shipping`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_shipping")
	}

	var resultSlice []*DTBShipping
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_shipping")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_shipping")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_shipping")
	}

	if len(dtbShippingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBShippings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbShippingR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBShippings = append(local.R.CreatorDTBShippings, foreign)
				if foreign.R == nil {
					foreign.R = &dtbShippingR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// LoadCreatorDTBTaxRules allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dtbMemberL) LoadCreatorDTBTaxRules(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDTBMember interface{}, mods queries.Applicator) error {
	var slice []*DTBMember
	var object *DTBMember

	if singular {
		object = maybeDTBMember.(*DTBMember)
	} else {
		slice = *maybeDTBMember.(*[]*DTBMember)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dtbMemberR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dtbMemberR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`dtb_tax_rule`), qm.WhereIn(`creator_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dtb_tax_rule")
	}

	var resultSlice []*DTBTaxRule
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dtb_tax_rule")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dtb_tax_rule")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dtb_tax_rule")
	}

	if len(dtbTaxRuleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatorDTBTaxRules = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dtbTaxRuleR{}
			}
			foreign.R.Creator = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatorID) {
				local.R.CreatorDTBTaxRules = append(local.R.CreatorDTBTaxRules, foreign)
				if foreign.R == nil {
					foreign.R = &dtbTaxRuleR{}
				}
				foreign.R.Creator = local
				break
			}
		}
	}

	return nil
}

// SetCreator of the dtbMember to the related item.
// Sets o.R.Creator to related.
// Adds o to related.R.CreatorDTBMembers.
func (o *DTBMember) SetCreator(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DTBMember) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_member` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
		strmangle.WhereClause("`", "`", 0, dtbMemberPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CreatorID, related.ID)
	if o.R == nil {
		o.R = &dtbMemberR{
			Creator: related,
		}
	} else {
		o.R.Creator = related
	}

	if related.R == nil {
		related.R = &dtbMemberR{
			CreatorDTBMembers: DTBMemberSlice{o},
		}
	} else {
		related.R.CreatorDTBMembers = append(related.R.CreatorDTBMembers, o)
	}

	return nil
}

// RemoveCreator relationship.
// Sets o.R.Creator to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBMember) RemoveCreator(ctx context.Context, exec boil.ContextExecutor, related *DTBMember) error {
	var err error

	queries.SetScanner(&o.CreatorID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Creator = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CreatorDTBMembers {
		if queries.Equal(o.CreatorID, ri.CreatorID) {
			continue
		}

		ln := len(related.R.CreatorDTBMembers)
		if ln > 1 && i < ln-1 {
			related.R.CreatorDTBMembers[i] = related.R.CreatorDTBMembers[ln-1]
		}
		related.R.CreatorDTBMembers = related.R.CreatorDTBMembers[:ln-1]
		break
	}
	return nil
}

// SetAuthority of the dtbMember to the related item.
// Sets o.R.Authority to related.
// Adds o to related.R.AuthorityDTBMembers.
func (o *DTBMember) SetAuthority(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBAuthority) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_member` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"authority_id"}),
		strmangle.WhereClause("`", "`", 0, dtbMemberPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AuthorityID, related.ID)
	if o.R == nil {
		o.R = &dtbMemberR{
			Authority: related,
		}
	} else {
		o.R.Authority = related
	}

	if related.R == nil {
		related.R = &mtbAuthorityR{
			AuthorityDTBMembers: DTBMemberSlice{o},
		}
	} else {
		related.R.AuthorityDTBMembers = append(related.R.AuthorityDTBMembers, o)
	}

	return nil
}

// RemoveAuthority relationship.
// Sets o.R.Authority to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBMember) RemoveAuthority(ctx context.Context, exec boil.ContextExecutor, related *MTBAuthority) error {
	var err error

	queries.SetScanner(&o.AuthorityID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("authority_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Authority = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AuthorityDTBMembers {
		if queries.Equal(o.AuthorityID, ri.AuthorityID) {
			continue
		}

		ln := len(related.R.AuthorityDTBMembers)
		if ln > 1 && i < ln-1 {
			related.R.AuthorityDTBMembers[i] = related.R.AuthorityDTBMembers[ln-1]
		}
		related.R.AuthorityDTBMembers = related.R.AuthorityDTBMembers[:ln-1]
		break
	}
	return nil
}

// SetWork of the dtbMember to the related item.
// Sets o.R.Work to related.
// Adds o to related.R.WorkDTBMembers.
func (o *DTBMember) SetWork(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MTBWork) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `dtb_member` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"work_id"}),
		strmangle.WhereClause("`", "`", 0, dtbMemberPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.WorkID, related.ID)
	if o.R == nil {
		o.R = &dtbMemberR{
			Work: related,
		}
	} else {
		o.R.Work = related
	}

	if related.R == nil {
		related.R = &mtbWorkR{
			WorkDTBMembers: DTBMemberSlice{o},
		}
	} else {
		related.R.WorkDTBMembers = append(related.R.WorkDTBMembers, o)
	}

	return nil
}

// RemoveWork relationship.
// Sets o.R.Work to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DTBMember) RemoveWork(ctx context.Context, exec boil.ContextExecutor, related *MTBWork) error {
	var err error

	queries.SetScanner(&o.WorkID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("work_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Work = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.WorkDTBMembers {
		if queries.Equal(o.WorkID, ri.WorkID) {
			continue
		}

		ln := len(related.R.WorkDTBMembers)
		if ln > 1 && i < ln-1 {
			related.R.WorkDTBMembers[i] = related.R.WorkDTBMembers[ln-1]
		}
		related.R.WorkDTBMembers = related.R.WorkDTBMembers[:ln-1]
		break
	}
	return nil
}

// AddCreatorDTBAuthorityRoles adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBAuthorityRoles.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBAuthorityRoles(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBAuthorityRole) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_authority_role` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbAuthorityRolePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBAuthorityRoles: related,
		}
	} else {
		o.R.CreatorDTBAuthorityRoles = append(o.R.CreatorDTBAuthorityRoles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbAuthorityRoleR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBAuthorityRoles removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBAuthorityRoles accordingly.
// Replaces o.R.CreatorDTBAuthorityRoles with related.
// Sets related.R.Creator's CreatorDTBAuthorityRoles accordingly.
func (o *DTBMember) SetCreatorDTBAuthorityRoles(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBAuthorityRole) error {
	query := "update `dtb_authority_role` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBAuthorityRoles {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBAuthorityRoles = nil
	}
	return o.AddCreatorDTBAuthorityRoles(ctx, exec, insert, related...)
}

// RemoveCreatorDTBAuthorityRoles relationships from objects passed in.
// Removes related items from R.CreatorDTBAuthorityRoles (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBAuthorityRoles(ctx context.Context, exec boil.ContextExecutor, related ...*DTBAuthorityRole) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBAuthorityRoles {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBAuthorityRoles)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBAuthorityRoles[i] = o.R.CreatorDTBAuthorityRoles[ln-1]
			}
			o.R.CreatorDTBAuthorityRoles = o.R.CreatorDTBAuthorityRoles[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBCategories adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBCategories.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBCategories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCategory) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_category` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbCategoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBCategories: related,
		}
	} else {
		o.R.CreatorDTBCategories = append(o.R.CreatorDTBCategories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbCategoryR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBCategories removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBCategories accordingly.
// Replaces o.R.CreatorDTBCategories with related.
// Sets related.R.Creator's CreatorDTBCategories accordingly.
func (o *DTBMember) SetCreatorDTBCategories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCategory) error {
	query := "update `dtb_category` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBCategories {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBCategories = nil
	}
	return o.AddCreatorDTBCategories(ctx, exec, insert, related...)
}

// RemoveCreatorDTBCategories relationships from objects passed in.
// Removes related items from R.CreatorDTBCategories (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBCategories(ctx context.Context, exec boil.ContextExecutor, related ...*DTBCategory) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBCategories {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBCategories)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBCategories[i] = o.R.CreatorDTBCategories[ln-1]
			}
			o.R.CreatorDTBCategories = o.R.CreatorDTBCategories[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBClassCategories adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBClassCategories.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBClassCategories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBClassCategory) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_class_category` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbClassCategoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBClassCategories: related,
		}
	} else {
		o.R.CreatorDTBClassCategories = append(o.R.CreatorDTBClassCategories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbClassCategoryR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBClassCategories removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBClassCategories accordingly.
// Replaces o.R.CreatorDTBClassCategories with related.
// Sets related.R.Creator's CreatorDTBClassCategories accordingly.
func (o *DTBMember) SetCreatorDTBClassCategories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBClassCategory) error {
	query := "update `dtb_class_category` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBClassCategories {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBClassCategories = nil
	}
	return o.AddCreatorDTBClassCategories(ctx, exec, insert, related...)
}

// RemoveCreatorDTBClassCategories relationships from objects passed in.
// Removes related items from R.CreatorDTBClassCategories (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBClassCategories(ctx context.Context, exec boil.ContextExecutor, related ...*DTBClassCategory) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBClassCategories {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBClassCategories)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBClassCategories[i] = o.R.CreatorDTBClassCategories[ln-1]
			}
			o.R.CreatorDTBClassCategories = o.R.CreatorDTBClassCategories[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBClassNames adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBClassNames.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBClassNames(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBClassName) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_class_name` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbClassNamePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBClassNames: related,
		}
	} else {
		o.R.CreatorDTBClassNames = append(o.R.CreatorDTBClassNames, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbClassNameR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBClassNames removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBClassNames accordingly.
// Replaces o.R.CreatorDTBClassNames with related.
// Sets related.R.Creator's CreatorDTBClassNames accordingly.
func (o *DTBMember) SetCreatorDTBClassNames(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBClassName) error {
	query := "update `dtb_class_name` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBClassNames {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBClassNames = nil
	}
	return o.AddCreatorDTBClassNames(ctx, exec, insert, related...)
}

// RemoveCreatorDTBClassNames relationships from objects passed in.
// Removes related items from R.CreatorDTBClassNames (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBClassNames(ctx context.Context, exec boil.ContextExecutor, related ...*DTBClassName) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBClassNames {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBClassNames)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBClassNames[i] = o.R.CreatorDTBClassNames[ln-1]
			}
			o.R.CreatorDTBClassNames = o.R.CreatorDTBClassNames[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBCSVS adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBCSVS.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBCSVS(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCSV) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_csv` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbCSVPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBCSVS: related,
		}
	} else {
		o.R.CreatorDTBCSVS = append(o.R.CreatorDTBCSVS, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbCSVR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBCSVS removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBCSVS accordingly.
// Replaces o.R.CreatorDTBCSVS with related.
// Sets related.R.Creator's CreatorDTBCSVS accordingly.
func (o *DTBMember) SetCreatorDTBCSVS(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBCSV) error {
	query := "update `dtb_csv` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBCSVS {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBCSVS = nil
	}
	return o.AddCreatorDTBCSVS(ctx, exec, insert, related...)
}

// RemoveCreatorDTBCSVS relationships from objects passed in.
// Removes related items from R.CreatorDTBCSVS (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBCSVS(ctx context.Context, exec boil.ContextExecutor, related ...*DTBCSV) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBCSVS {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBCSVS)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBCSVS[i] = o.R.CreatorDTBCSVS[ln-1]
			}
			o.R.CreatorDTBCSVS = o.R.CreatorDTBCSVS[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBDeliveries adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBDeliveries.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBDeliveries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBDelivery) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_delivery` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbDeliveryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBDeliveries: related,
		}
	} else {
		o.R.CreatorDTBDeliveries = append(o.R.CreatorDTBDeliveries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbDeliveryR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBDeliveries removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBDeliveries accordingly.
// Replaces o.R.CreatorDTBDeliveries with related.
// Sets related.R.Creator's CreatorDTBDeliveries accordingly.
func (o *DTBMember) SetCreatorDTBDeliveries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBDelivery) error {
	query := "update `dtb_delivery` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBDeliveries {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBDeliveries = nil
	}
	return o.AddCreatorDTBDeliveries(ctx, exec, insert, related...)
}

// RemoveCreatorDTBDeliveries relationships from objects passed in.
// Removes related items from R.CreatorDTBDeliveries (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBDeliveries(ctx context.Context, exec boil.ContextExecutor, related ...*DTBDelivery) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBDeliveries {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBDeliveries)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBDeliveries[i] = o.R.CreatorDTBDeliveries[ln-1]
			}
			o.R.CreatorDTBDeliveries = o.R.CreatorDTBDeliveries[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBMailHistories adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBMailHistories.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBMailHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBMailHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_mail_history` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbMailHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBMailHistories: related,
		}
	} else {
		o.R.CreatorDTBMailHistories = append(o.R.CreatorDTBMailHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbMailHistoryR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBMailHistories removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBMailHistories accordingly.
// Replaces o.R.CreatorDTBMailHistories with related.
// Sets related.R.Creator's CreatorDTBMailHistories accordingly.
func (o *DTBMember) SetCreatorDTBMailHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBMailHistory) error {
	query := "update `dtb_mail_history` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBMailHistories {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBMailHistories = nil
	}
	return o.AddCreatorDTBMailHistories(ctx, exec, insert, related...)
}

// RemoveCreatorDTBMailHistories relationships from objects passed in.
// Removes related items from R.CreatorDTBMailHistories (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBMailHistories(ctx context.Context, exec boil.ContextExecutor, related ...*DTBMailHistory) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBMailHistories {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBMailHistories)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBMailHistories[i] = o.R.CreatorDTBMailHistories[ln-1]
			}
			o.R.CreatorDTBMailHistories = o.R.CreatorDTBMailHistories[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBMailTemplates adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBMailTemplates.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBMailTemplates(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBMailTemplate) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_mail_template` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbMailTemplatePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBMailTemplates: related,
		}
	} else {
		o.R.CreatorDTBMailTemplates = append(o.R.CreatorDTBMailTemplates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbMailTemplateR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBMailTemplates removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBMailTemplates accordingly.
// Replaces o.R.CreatorDTBMailTemplates with related.
// Sets related.R.Creator's CreatorDTBMailTemplates accordingly.
func (o *DTBMember) SetCreatorDTBMailTemplates(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBMailTemplate) error {
	query := "update `dtb_mail_template` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBMailTemplates {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBMailTemplates = nil
	}
	return o.AddCreatorDTBMailTemplates(ctx, exec, insert, related...)
}

// RemoveCreatorDTBMailTemplates relationships from objects passed in.
// Removes related items from R.CreatorDTBMailTemplates (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBMailTemplates(ctx context.Context, exec boil.ContextExecutor, related ...*DTBMailTemplate) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBMailTemplates {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBMailTemplates)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBMailTemplates[i] = o.R.CreatorDTBMailTemplates[ln-1]
			}
			o.R.CreatorDTBMailTemplates = o.R.CreatorDTBMailTemplates[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBMembers adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBMembers.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBMembers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBMember) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_member` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbMemberPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBMembers: related,
		}
	} else {
		o.R.CreatorDTBMembers = append(o.R.CreatorDTBMembers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbMemberR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBMembers removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBMembers accordingly.
// Replaces o.R.CreatorDTBMembers with related.
// Sets related.R.Creator's CreatorDTBMembers accordingly.
func (o *DTBMember) SetCreatorDTBMembers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBMember) error {
	query := "update `dtb_member` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBMembers {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBMembers = nil
	}
	return o.AddCreatorDTBMembers(ctx, exec, insert, related...)
}

// RemoveCreatorDTBMembers relationships from objects passed in.
// Removes related items from R.CreatorDTBMembers (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBMembers(ctx context.Context, exec boil.ContextExecutor, related ...*DTBMember) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBMembers {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBMembers)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBMembers[i] = o.R.CreatorDTBMembers[ln-1]
			}
			o.R.CreatorDTBMembers = o.R.CreatorDTBMembers[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBNews adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBNews.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBNews(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBNews) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_news` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbNewsPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBNews: related,
		}
	} else {
		o.R.CreatorDTBNews = append(o.R.CreatorDTBNews, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbNewsR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBNews removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBNews accordingly.
// Replaces o.R.CreatorDTBNews with related.
// Sets related.R.Creator's CreatorDTBNews accordingly.
func (o *DTBMember) SetCreatorDTBNews(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBNews) error {
	query := "update `dtb_news` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBNews {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBNews = nil
	}
	return o.AddCreatorDTBNews(ctx, exec, insert, related...)
}

// RemoveCreatorDTBNews relationships from objects passed in.
// Removes related items from R.CreatorDTBNews (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBNews(ctx context.Context, exec boil.ContextExecutor, related ...*DTBNews) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBNews {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBNews)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBNews[i] = o.R.CreatorDTBNews[ln-1]
			}
			o.R.CreatorDTBNews = o.R.CreatorDTBNews[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBPayments adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBPayments.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBPayments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBPayment) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_payment` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbPaymentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBPayments: related,
		}
	} else {
		o.R.CreatorDTBPayments = append(o.R.CreatorDTBPayments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbPaymentR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBPayments removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBPayments accordingly.
// Replaces o.R.CreatorDTBPayments with related.
// Sets related.R.Creator's CreatorDTBPayments accordingly.
func (o *DTBMember) SetCreatorDTBPayments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBPayment) error {
	query := "update `dtb_payment` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBPayments {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBPayments = nil
	}
	return o.AddCreatorDTBPayments(ctx, exec, insert, related...)
}

// RemoveCreatorDTBPayments relationships from objects passed in.
// Removes related items from R.CreatorDTBPayments (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBPayments(ctx context.Context, exec boil.ContextExecutor, related ...*DTBPayment) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBPayments {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBPayments)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBPayments[i] = o.R.CreatorDTBPayments[ln-1]
			}
			o.R.CreatorDTBPayments = o.R.CreatorDTBPayments[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBProducts adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBProducts.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBProducts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProduct) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_product` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbProductPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBProducts: related,
		}
	} else {
		o.R.CreatorDTBProducts = append(o.R.CreatorDTBProducts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbProductR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBProducts removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBProducts accordingly.
// Replaces o.R.CreatorDTBProducts with related.
// Sets related.R.Creator's CreatorDTBProducts accordingly.
func (o *DTBMember) SetCreatorDTBProducts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProduct) error {
	query := "update `dtb_product` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBProducts {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBProducts = nil
	}
	return o.AddCreatorDTBProducts(ctx, exec, insert, related...)
}

// RemoveCreatorDTBProducts relationships from objects passed in.
// Removes related items from R.CreatorDTBProducts (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBProducts(ctx context.Context, exec boil.ContextExecutor, related ...*DTBProduct) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBProducts {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBProducts)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBProducts[i] = o.R.CreatorDTBProducts[ln-1]
			}
			o.R.CreatorDTBProducts = o.R.CreatorDTBProducts[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBProductClasses adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBProductClasses.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBProductClasses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductClass) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_product_class` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbProductClassPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBProductClasses: related,
		}
	} else {
		o.R.CreatorDTBProductClasses = append(o.R.CreatorDTBProductClasses, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbProductClassR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBProductClasses removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBProductClasses accordingly.
// Replaces o.R.CreatorDTBProductClasses with related.
// Sets related.R.Creator's CreatorDTBProductClasses accordingly.
func (o *DTBMember) SetCreatorDTBProductClasses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductClass) error {
	query := "update `dtb_product_class` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBProductClasses {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBProductClasses = nil
	}
	return o.AddCreatorDTBProductClasses(ctx, exec, insert, related...)
}

// RemoveCreatorDTBProductClasses relationships from objects passed in.
// Removes related items from R.CreatorDTBProductClasses (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBProductClasses(ctx context.Context, exec boil.ContextExecutor, related ...*DTBProductClass) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBProductClasses {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBProductClasses)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBProductClasses[i] = o.R.CreatorDTBProductClasses[ln-1]
			}
			o.R.CreatorDTBProductClasses = o.R.CreatorDTBProductClasses[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBProductImages adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBProductImages.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBProductImages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductImage) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_product_image` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbProductImagePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBProductImages: related,
		}
	} else {
		o.R.CreatorDTBProductImages = append(o.R.CreatorDTBProductImages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbProductImageR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBProductImages removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBProductImages accordingly.
// Replaces o.R.CreatorDTBProductImages with related.
// Sets related.R.Creator's CreatorDTBProductImages accordingly.
func (o *DTBMember) SetCreatorDTBProductImages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductImage) error {
	query := "update `dtb_product_image` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBProductImages {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBProductImages = nil
	}
	return o.AddCreatorDTBProductImages(ctx, exec, insert, related...)
}

// RemoveCreatorDTBProductImages relationships from objects passed in.
// Removes related items from R.CreatorDTBProductImages (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBProductImages(ctx context.Context, exec boil.ContextExecutor, related ...*DTBProductImage) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBProductImages {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBProductImages)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBProductImages[i] = o.R.CreatorDTBProductImages[ln-1]
			}
			o.R.CreatorDTBProductImages = o.R.CreatorDTBProductImages[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBProductStocks adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBProductStocks.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBProductStocks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductStock) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_product_stock` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbProductStockPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBProductStocks: related,
		}
	} else {
		o.R.CreatorDTBProductStocks = append(o.R.CreatorDTBProductStocks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbProductStockR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBProductStocks removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBProductStocks accordingly.
// Replaces o.R.CreatorDTBProductStocks with related.
// Sets related.R.Creator's CreatorDTBProductStocks accordingly.
func (o *DTBMember) SetCreatorDTBProductStocks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductStock) error {
	query := "update `dtb_product_stock` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBProductStocks {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBProductStocks = nil
	}
	return o.AddCreatorDTBProductStocks(ctx, exec, insert, related...)
}

// RemoveCreatorDTBProductStocks relationships from objects passed in.
// Removes related items from R.CreatorDTBProductStocks (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBProductStocks(ctx context.Context, exec boil.ContextExecutor, related ...*DTBProductStock) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBProductStocks {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBProductStocks)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBProductStocks[i] = o.R.CreatorDTBProductStocks[ln-1]
			}
			o.R.CreatorDTBProductStocks = o.R.CreatorDTBProductStocks[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBProductTags adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBProductTags.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBProductTags(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductTag) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_product_tag` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbProductTagPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBProductTags: related,
		}
	} else {
		o.R.CreatorDTBProductTags = append(o.R.CreatorDTBProductTags, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbProductTagR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBProductTags removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBProductTags accordingly.
// Replaces o.R.CreatorDTBProductTags with related.
// Sets related.R.Creator's CreatorDTBProductTags accordingly.
func (o *DTBMember) SetCreatorDTBProductTags(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBProductTag) error {
	query := "update `dtb_product_tag` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBProductTags {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBProductTags = nil
	}
	return o.AddCreatorDTBProductTags(ctx, exec, insert, related...)
}

// RemoveCreatorDTBProductTags relationships from objects passed in.
// Removes related items from R.CreatorDTBProductTags (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBProductTags(ctx context.Context, exec boil.ContextExecutor, related ...*DTBProductTag) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBProductTags {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBProductTags)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBProductTags[i] = o.R.CreatorDTBProductTags[ln-1]
			}
			o.R.CreatorDTBProductTags = o.R.CreatorDTBProductTags[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBShippings adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBShippings.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBShippings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBShipping) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_shipping` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbShippingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBShippings: related,
		}
	} else {
		o.R.CreatorDTBShippings = append(o.R.CreatorDTBShippings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbShippingR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBShippings removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBShippings accordingly.
// Replaces o.R.CreatorDTBShippings with related.
// Sets related.R.Creator's CreatorDTBShippings accordingly.
func (o *DTBMember) SetCreatorDTBShippings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBShipping) error {
	query := "update `dtb_shipping` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBShippings {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBShippings = nil
	}
	return o.AddCreatorDTBShippings(ctx, exec, insert, related...)
}

// RemoveCreatorDTBShippings relationships from objects passed in.
// Removes related items from R.CreatorDTBShippings (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBShippings(ctx context.Context, exec boil.ContextExecutor, related ...*DTBShipping) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBShippings {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBShippings)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBShippings[i] = o.R.CreatorDTBShippings[ln-1]
			}
			o.R.CreatorDTBShippings = o.R.CreatorDTBShippings[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatorDTBTaxRules adds the given related objects to the existing relationships
// of the dtb_member, optionally inserting them as new records.
// Appends related to o.R.CreatorDTBTaxRules.
// Sets related.R.Creator appropriately.
func (o *DTBMember) AddCreatorDTBTaxRules(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBTaxRule) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatorID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `dtb_tax_rule` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"creator_id"}),
				strmangle.WhereClause("`", "`", 0, dtbTaxRulePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatorID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dtbMemberR{
			CreatorDTBTaxRules: related,
		}
	} else {
		o.R.CreatorDTBTaxRules = append(o.R.CreatorDTBTaxRules, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dtbTaxRuleR{
				Creator: o,
			}
		} else {
			rel.R.Creator = o
		}
	}
	return nil
}

// SetCreatorDTBTaxRules removes all previously related items of the
// dtb_member replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Creator's CreatorDTBTaxRules accordingly.
// Replaces o.R.CreatorDTBTaxRules with related.
// Sets related.R.Creator's CreatorDTBTaxRules accordingly.
func (o *DTBMember) SetCreatorDTBTaxRules(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DTBTaxRule) error {
	query := "update `dtb_tax_rule` set `creator_id` = null where `creator_id` = ?"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatorDTBTaxRules {
			queries.SetScanner(&rel.CreatorID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Creator = nil
		}

		o.R.CreatorDTBTaxRules = nil
	}
	return o.AddCreatorDTBTaxRules(ctx, exec, insert, related...)
}

// RemoveCreatorDTBTaxRules relationships from objects passed in.
// Removes related items from R.CreatorDTBTaxRules (uses pointer comparison, removal does not keep order)
// Sets related.R.Creator.
func (o *DTBMember) RemoveCreatorDTBTaxRules(ctx context.Context, exec boil.ContextExecutor, related ...*DTBTaxRule) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatorID, nil)
		if rel.R != nil {
			rel.R.Creator = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("creator_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatorDTBTaxRules {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatorDTBTaxRules)
			if ln > 1 && i < ln-1 {
				o.R.CreatorDTBTaxRules[i] = o.R.CreatorDTBTaxRules[ln-1]
			}
			o.R.CreatorDTBTaxRules = o.R.CreatorDTBTaxRules[:ln-1]
			break
		}
	}

	return nil
}

// DTBMembers retrieves all the records using an executor.
func DTBMembers(mods ...qm.QueryMod) dtbMemberQuery {
	mods = append(mods, qm.From("`dtb_member`"))
	return dtbMemberQuery{NewQuery(mods...)}
}

// FindDTBMember retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDTBMember(ctx context.Context, exec boil.ContextExecutor, iD uint, selectCols ...string) (*DTBMember, error) {
	dtbMemberObj := &DTBMember{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `dtb_member` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, dtbMemberObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from dtb_member")
	}

	return dtbMemberObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DTBMember) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_member provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbMemberColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dtbMemberInsertCacheMut.RLock()
	cache, cached := dtbMemberInsertCache[key]
	dtbMemberInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dtbMemberColumns,
			dtbMemberColumnsWithDefault,
			dtbMemberColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dtbMemberType, dtbMemberMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dtbMemberType, dtbMemberMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `dtb_member` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `dtb_member` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `dtb_member` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dtbMemberPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into dtb_member")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbMemberMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_member")
	}

CacheNoHooks:
	if !cached {
		dtbMemberInsertCacheMut.Lock()
		dtbMemberInsertCache[key] = cache
		dtbMemberInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DTBMember.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DTBMember) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	dtbMemberUpdateCacheMut.RLock()
	cache, cached := dtbMemberUpdateCache[key]
	dtbMemberUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dtbMemberColumns,
			dtbMemberPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("model: unable to update dtb_member, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `dtb_member` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dtbMemberPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dtbMemberType, dtbMemberMapping, append(wl, dtbMemberPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update dtb_member row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by update for dtb_member")
	}

	if !cached {
		dtbMemberUpdateCacheMut.Lock()
		dtbMemberUpdateCache[key] = cache
		dtbMemberUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q dtbMemberQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all for dtb_member")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected for dtb_member")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DTBMemberSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbMemberPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `dtb_member` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbMemberPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all in dtbMember slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected all in update all dtbMember")
	}
	return rowsAff, nil
}

var mySQLDTBMemberUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DTBMember) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("model: no dtb_member provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dtbMemberColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDTBMemberUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dtbMemberUpsertCacheMut.RLock()
	cache, cached := dtbMemberUpsertCache[key]
	dtbMemberUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dtbMemberColumns,
			dtbMemberColumnsWithDefault,
			dtbMemberColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			dtbMemberColumns,
			dtbMemberPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("model: unable to upsert dtb_member, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "dtb_member", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `dtb_member` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dtbMemberType, dtbMemberMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dtbMemberType, dtbMemberMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to upsert for dtb_member")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == dtbMemberMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dtbMemberType, dtbMemberMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "model: unable to retrieve unique values for dtb_member")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for dtb_member")
	}

CacheNoHooks:
	if !cached {
		dtbMemberUpsertCacheMut.Lock()
		dtbMemberUpsertCache[key] = cache
		dtbMemberUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DTBMember record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DTBMember) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBMember provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dtbMemberPrimaryKeyMapping)
	sql := "DELETE FROM `dtb_member` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete from dtb_member")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by delete for dtb_member")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q dtbMemberQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("model: no dtbMemberQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtb_member")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_member")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DTBMemberSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no DTBMember slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(dtbMemberBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbMemberPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `dtb_member` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbMemberPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from dtbMember slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for dtb_member")
	}

	if len(dtbMemberAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DTBMember) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDTBMember(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DTBMemberSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DTBMemberSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dtbMemberPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `dtb_member`.* FROM `dtb_member` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dtbMemberPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in DTBMemberSlice")
	}

	*o = slice

	return nil
}

// DTBMemberExists checks if the DTBMember row exists.
func DTBMemberExists(ctx context.Context, exec boil.ContextExecutor, iD uint) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `dtb_member` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if dtb_member exists")
	}

	return exists, nil
}
